/**
 * @license React
 * eslint-plugin-react-hooks.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

if (process.env.NODE_ENV !== "production") {
  (function() {
'use strict';

var core$1 = require('@babel/core');
var BabelParser = require('@babel/parser');
var v4 = require('zod/v4');
var v4$1 = require('zod-validation-error/v4');
var crypto = require('crypto');
var HermesParser = require('hermes-parser');
var util = require('util');

const SETTINGS_KEY = 'react-hooks';
const SETTINGS_ADDITIONAL_EFFECT_HOOKS_KEY = 'additionalEffectHooks';
function getAdditionalEffectHooksFromSettings(settings) {
    var _a;
    const additionalHooks = (_a = settings[SETTINGS_KEY]) === null || _a === void 0 ? void 0 : _a[SETTINGS_ADDITIONAL_EFFECT_HOOKS_KEY];
    if (additionalHooks != null && typeof additionalHooks === 'string') {
        return new RegExp(additionalHooks);
    }
    return undefined;
}

const rule$1 = {
    meta: {
        type: 'suggestion',
        docs: {
            description: 'verifies the list of dependencies for Hooks like useEffect and similar',
            recommended: true,
            url: 'https://github.com/facebook/react/issues/14920',
        },
        fixable: 'code',
        hasSuggestions: true,
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                enableDangerousAutofixThisMayCauseInfiniteLoops: false,
                properties: {
                    additionalHooks: {
                        type: 'string',
                    },
                    enableDangerousAutofixThisMayCauseInfiniteLoops: {
                        type: 'boolean',
                    },
                    experimental_autoDependenciesHooks: {
                        type: 'array',
                        items: {
                            type: 'string',
                        },
                    },
                    requireExplicitEffectDeps: {
                        type: 'boolean',
                    },
                },
            },
        ],
    },
    create(context) {
        const rawOptions = context.options && context.options[0];
        const settings = context.settings || {};
        const additionalHooks = rawOptions && rawOptions.additionalHooks
            ? new RegExp(rawOptions.additionalHooks)
            : getAdditionalEffectHooksFromSettings(settings);
        const enableDangerousAutofixThisMayCauseInfiniteLoops = (rawOptions &&
            rawOptions.enableDangerousAutofixThisMayCauseInfiniteLoops) ||
            false;
        const experimental_autoDependenciesHooks = rawOptions && Array.isArray(rawOptions.experimental_autoDependenciesHooks)
            ? rawOptions.experimental_autoDependenciesHooks
            : [];
        const requireExplicitEffectDeps = (rawOptions && rawOptions.requireExplicitEffectDeps) || false;
        const options = {
            additionalHooks,
            experimental_autoDependenciesHooks,
            enableDangerousAutofixThisMayCauseInfiniteLoops,
            requireExplicitEffectDeps,
        };
        function reportProblem(problem) {
            if (enableDangerousAutofixThisMayCauseInfiniteLoops) {
                if (Array.isArray(problem.suggest) &&
                    problem.suggest.length > 0 &&
                    problem.suggest[0]) {
                    problem.fix = problem.suggest[0].fix;
                }
            }
            context.report(problem);
        }
        const getSourceCode = typeof context.getSourceCode === 'function'
            ? () => {
                return context.getSourceCode();
            }
            : () => {
                return context.sourceCode;
            };
        const getScope = typeof context.getScope === 'function'
            ? () => {
                return context.getScope();
            }
            : (node) => {
                return context.sourceCode.getScope(node);
            };
        const scopeManager = getSourceCode().scopeManager;
        const setStateCallSites = new WeakMap();
        const stateVariables = new WeakSet();
        const stableKnownValueCache = new WeakMap();
        const functionWithoutCapturedValueCache = new WeakMap();
        const useEffectEventVariables = new WeakSet();
        function memoizeWithWeakMap(fn, map) {
            return function (arg) {
                if (map.has(arg)) {
                    return map.get(arg);
                }
                const result = fn(arg);
                map.set(arg, result);
                return result;
            };
        }
        function visitFunctionWithDependencies(node, declaredDependenciesNode, reactiveHook, reactiveHookName, isEffect, isAutoDepsHook) {
            if (isEffect && node.async) {
                reportProblem({
                    node: node,
                    message: `Effect callbacks are synchronous to prevent race conditions. ` +
                        `Put the async function inside:\n\n` +
                        'useEffect(() => {\n' +
                        '  async function fetchData() {\n' +
                        '    // You can await here\n' +
                        '    const response = await MyAPI.getData(someId);\n' +
                        '    // ...\n' +
                        '  }\n' +
                        '  fetchData();\n' +
                        `}, [someId]); // Or [] if effect doesn't need props or state\n\n` +
                        'Learn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching',
                });
            }
            const scope = scopeManager.acquire(node);
            if (!scope) {
                throw new Error('Unable to acquire scope for the current node. This is a bug in eslint-plugin-react-hooks, please file an issue.');
            }
            const pureScopes = new Set();
            let componentScope = null;
            {
                let currentScope = scope.upper;
                while (currentScope) {
                    pureScopes.add(currentScope);
                    if (currentScope.type === 'function' ||
                        currentScope.type === 'hook' ||
                        currentScope.type === 'component') {
                        break;
                    }
                    currentScope = currentScope.upper;
                }
                if (!currentScope) {
                    return;
                }
                componentScope = currentScope;
            }
            const isArray = Array.isArray;
            function isStableKnownHookValue(resolved) {
                if (!isArray(resolved.defs)) {
                    return false;
                }
                const def = resolved.defs[0];
                if (def == null) {
                    return false;
                }
                const defNode = def.node;
                if (defNode.type !== 'VariableDeclarator') {
                    return false;
                }
                let init = defNode.init;
                if (init == null) {
                    return false;
                }
                while (init.type === 'TSAsExpression' || init.type === 'AsExpression') {
                    init = init.expression;
                }
                let declaration = defNode.parent;
                if (declaration == null && componentScope != null) {
                    fastFindReferenceWithParent(componentScope.block, def.node.id);
                    declaration = def.node.parent;
                    if (declaration == null) {
                        return false;
                    }
                }
                if (declaration != null &&
                    'kind' in declaration &&
                    declaration.kind === 'const' &&
                    init.type === 'Literal' &&
                    (typeof init.value === 'string' ||
                        typeof init.value === 'number' ||
                        init.value === null)) {
                    return true;
                }
                if (init.type !== 'CallExpression') {
                    return false;
                }
                let callee = init.callee;
                if (callee.type === 'MemberExpression' &&
                    'name' in callee.object &&
                    callee.object.name === 'React' &&
                    callee.property != null &&
                    !callee.computed) {
                    callee = callee.property;
                }
                if (callee.type !== 'Identifier') {
                    return false;
                }
                const definitionNode = def.node;
                const id = definitionNode.id;
                const { name } = callee;
                if (name === 'useRef' && id.type === 'Identifier') {
                    return true;
                }
                else if (isUseEffectEventIdentifier$1(callee) &&
                    id.type === 'Identifier') {
                    for (const ref of resolved.references) {
                        if (ref !== id) {
                            useEffectEventVariables.add(ref.identifier);
                        }
                    }
                    return true;
                }
                else if (name === 'useState' ||
                    name === 'useReducer' ||
                    name === 'useActionState') {
                    if (id.type === 'ArrayPattern' &&
                        id.elements.length === 2 &&
                        isArray(resolved.identifiers)) {
                        if (id.elements[1] === resolved.identifiers[0]) {
                            if (name === 'useState') {
                                const references = resolved.references;
                                let writeCount = 0;
                                for (const reference of references) {
                                    if (reference.isWrite()) {
                                        writeCount++;
                                    }
                                    if (writeCount > 1) {
                                        return false;
                                    }
                                    setStateCallSites.set(reference.identifier, id.elements[0]);
                                }
                            }
                            return true;
                        }
                        else if (id.elements[0] === resolved.identifiers[0]) {
                            if (name === 'useState') {
                                const references = resolved.references;
                                for (const reference of references) {
                                    stateVariables.add(reference.identifier);
                                }
                            }
                            return false;
                        }
                    }
                }
                else if (name === 'useTransition') {
                    if (id.type === 'ArrayPattern' &&
                        id.elements.length === 2 &&
                        Array.isArray(resolved.identifiers)) {
                        if (id.elements[1] === resolved.identifiers[0]) {
                            return true;
                        }
                    }
                }
                return false;
            }
            function isFunctionWithoutCapturedValues(resolved) {
                if (!isArray(resolved.defs)) {
                    return false;
                }
                const def = resolved.defs[0];
                if (def == null) {
                    return false;
                }
                if (def.node == null || def.node.id == null) {
                    return false;
                }
                const fnNode = def.node;
                const childScopes = (componentScope === null || componentScope === void 0 ? void 0 : componentScope.childScopes) || [];
                let fnScope = null;
                for (const childScope of childScopes) {
                    const childScopeBlock = childScope.block;
                    if ((fnNode.type === 'FunctionDeclaration' &&
                        childScopeBlock === fnNode) ||
                        (fnNode.type === 'VariableDeclarator' &&
                            childScopeBlock.parent === fnNode)) {
                        fnScope = childScope;
                        break;
                    }
                }
                if (fnScope == null) {
                    return false;
                }
                for (const ref of fnScope.through) {
                    if (ref.resolved == null) {
                        continue;
                    }
                    if (pureScopes.has(ref.resolved.scope) &&
                        !memoizedIsStableKnownHookValue(ref.resolved)) {
                        return false;
                    }
                }
                return true;
            }
            const memoizedIsStableKnownHookValue = memoizeWithWeakMap(isStableKnownHookValue, stableKnownValueCache);
            const memoizedIsFunctionWithoutCapturedValues = memoizeWithWeakMap(isFunctionWithoutCapturedValues, functionWithoutCapturedValueCache);
            const currentRefsInEffectCleanup = new Map();
            function isInsideEffectCleanup(reference) {
                let curScope = reference.from;
                let isInReturnedFunction = false;
                while (curScope != null && curScope.block !== node) {
                    if (curScope.type === 'function') {
                        isInReturnedFunction =
                            curScope.block.parent != null &&
                                curScope.block.parent.type === 'ReturnStatement';
                    }
                    curScope = curScope.upper;
                }
                return isInReturnedFunction;
            }
            const dependencies = new Map();
            const optionalChains = new Map();
            gatherDependenciesRecursively(scope);
            function gatherDependenciesRecursively(currentScope) {
                var _a, _b, _c, _d, _e;
                for (const reference of currentScope.references) {
                    if (!reference.resolved) {
                        continue;
                    }
                    if (!pureScopes.has(reference.resolved.scope)) {
                        continue;
                    }
                    const referenceNode = fastFindReferenceWithParent(node, reference.identifier);
                    if (referenceNode == null) {
                        continue;
                    }
                    const dependencyNode = getDependency(referenceNode);
                    const dependency = analyzePropertyChain(dependencyNode, optionalChains);
                    if (isEffect &&
                        dependencyNode.type === 'Identifier' &&
                        (((_a = dependencyNode.parent) === null || _a === void 0 ? void 0 : _a.type) === 'MemberExpression' ||
                            ((_b = dependencyNode.parent) === null || _b === void 0 ? void 0 : _b.type) === 'OptionalMemberExpression') &&
                        !dependencyNode.parent.computed &&
                        dependencyNode.parent.property.type === 'Identifier' &&
                        dependencyNode.parent.property.name === 'current' &&
                        isInsideEffectCleanup(reference)) {
                        currentRefsInEffectCleanup.set(dependency, {
                            reference,
                            dependencyNode,
                        });
                    }
                    if (((_c = dependencyNode.parent) === null || _c === void 0 ? void 0 : _c.type) === 'TSTypeQuery' ||
                        ((_d = dependencyNode.parent) === null || _d === void 0 ? void 0 : _d.type) === 'TSTypeReference') {
                        continue;
                    }
                    const def = reference.resolved.defs[0];
                    if (def == null) {
                        continue;
                    }
                    if (def.node != null && def.node.init === node.parent) {
                        continue;
                    }
                    if (def.type === 'TypeParameter') {
                        continue;
                    }
                    if (!dependencies.has(dependency)) {
                        const resolved = reference.resolved;
                        const isStable = memoizedIsStableKnownHookValue(resolved) ||
                            memoizedIsFunctionWithoutCapturedValues(resolved);
                        dependencies.set(dependency, {
                            isStable,
                            references: [reference],
                        });
                    }
                    else {
                        (_e = dependencies.get(dependency)) === null || _e === void 0 ? void 0 : _e.references.push(reference);
                    }
                }
                for (const childScope of currentScope.childScopes) {
                    gatherDependenciesRecursively(childScope);
                }
            }
            currentRefsInEffectCleanup.forEach(({ reference, dependencyNode }, dependency) => {
                var _a, _b;
                const references = ((_a = reference.resolved) === null || _a === void 0 ? void 0 : _a.references) || [];
                let foundCurrentAssignment = false;
                for (const ref of references) {
                    const { identifier } = ref;
                    const { parent } = identifier;
                    if (parent != null &&
                        parent.type === 'MemberExpression' &&
                        !parent.computed &&
                        parent.property.type === 'Identifier' &&
                        parent.property.name === 'current' &&
                        ((_b = parent.parent) === null || _b === void 0 ? void 0 : _b.type) === 'AssignmentExpression' &&
                        parent.parent.left === parent) {
                        foundCurrentAssignment = true;
                        break;
                    }
                }
                if (foundCurrentAssignment) {
                    return;
                }
                reportProblem({
                    node: dependencyNode.parent.property,
                    message: `The ref value '${dependency}.current' will likely have ` +
                        `changed by the time this effect cleanup function runs. If ` +
                        `this ref points to a node rendered by React, copy ` +
                        `'${dependency}.current' to a variable inside the effect, and ` +
                        `use that variable in the cleanup function.`,
                });
            });
            const staleAssignments = new Set();
            function reportStaleAssignment(writeExpr, key) {
                if (staleAssignments.has(key)) {
                    return;
                }
                staleAssignments.add(key);
                reportProblem({
                    node: writeExpr,
                    message: `Assignments to the '${key}' variable from inside React Hook ` +
                        `${getSourceCode().getText(reactiveHook)} will be lost after each ` +
                        `render. To preserve the value over time, store it in a useRef ` +
                        `Hook and keep the mutable value in the '.current' property. ` +
                        `Otherwise, you can move this variable directly inside ` +
                        `${getSourceCode().getText(reactiveHook)}.`,
                });
            }
            const stableDependencies = new Set();
            dependencies.forEach(({ isStable, references }, key) => {
                if (isStable) {
                    stableDependencies.add(key);
                }
                references.forEach(reference => {
                    if (reference.writeExpr) {
                        reportStaleAssignment(reference.writeExpr, key);
                    }
                });
            });
            if (staleAssignments.size > 0) {
                return;
            }
            if (!declaredDependenciesNode) {
                if (isAutoDepsHook) {
                    return;
                }
                let setStateInsideEffectWithoutDeps = null;
                dependencies.forEach(({ references }, key) => {
                    if (setStateInsideEffectWithoutDeps) {
                        return;
                    }
                    references.forEach(reference => {
                        if (setStateInsideEffectWithoutDeps) {
                            return;
                        }
                        const id = reference.identifier;
                        const isSetState = setStateCallSites.has(id);
                        if (!isSetState) {
                            return;
                        }
                        let fnScope = reference.from;
                        while (fnScope != null && fnScope.type !== 'function') {
                            fnScope = fnScope.upper;
                        }
                        const isDirectlyInsideEffect = (fnScope === null || fnScope === void 0 ? void 0 : fnScope.block) === node;
                        if (isDirectlyInsideEffect) {
                            setStateInsideEffectWithoutDeps = key;
                        }
                    });
                });
                if (setStateInsideEffectWithoutDeps) {
                    const { suggestedDependencies } = collectRecommendations({
                        dependencies,
                        declaredDependencies: [],
                        stableDependencies,
                        externalDependencies: new Set(),
                        isEffect: true,
                    });
                    reportProblem({
                        node: reactiveHook,
                        message: `React Hook ${reactiveHookName} contains a call to '${setStateInsideEffectWithoutDeps}'. ` +
                            `Without a list of dependencies, this can lead to an infinite chain of updates. ` +
                            `To fix this, pass [` +
                            suggestedDependencies.join(', ') +
                            `] as a second argument to the ${reactiveHookName} Hook.`,
                        suggest: [
                            {
                                desc: `Add dependencies array: [${suggestedDependencies.join(', ')}]`,
                                fix(fixer) {
                                    return fixer.insertTextAfter(node, `, [${suggestedDependencies.join(', ')}]`);
                                },
                            },
                        ],
                    });
                }
                return;
            }
            if (isAutoDepsHook &&
                declaredDependenciesNode.type === 'Literal' &&
                declaredDependenciesNode.value === null) {
                return;
            }
            const declaredDependencies = [];
            const externalDependencies = new Set();
            const isArrayExpression = declaredDependenciesNode.type === 'ArrayExpression';
            const isTSAsArrayExpression = declaredDependenciesNode.type === 'TSAsExpression' &&
                declaredDependenciesNode.expression.type === 'ArrayExpression';
            if (!isArrayExpression && !isTSAsArrayExpression) {
                reportProblem({
                    node: declaredDependenciesNode,
                    message: `React Hook ${getSourceCode().getText(reactiveHook)} was passed a ` +
                        'dependency list that is not an array literal. This means we ' +
                        "can't statically verify whether you've passed the correct " +
                        'dependencies.',
                });
            }
            else {
                const arrayExpression = isTSAsArrayExpression
                    ? declaredDependenciesNode.expression
                    : declaredDependenciesNode;
                arrayExpression.elements.forEach(declaredDependencyNode => {
                    if (declaredDependencyNode === null) {
                        return;
                    }
                    if (declaredDependencyNode.type === 'SpreadElement') {
                        reportProblem({
                            node: declaredDependencyNode,
                            message: `React Hook ${getSourceCode().getText(reactiveHook)} has a spread ` +
                                "element in its dependency array. This means we can't " +
                                "statically verify whether you've passed the " +
                                'correct dependencies.',
                        });
                        return;
                    }
                    if (useEffectEventVariables.has(declaredDependencyNode)) {
                        reportProblem({
                            node: declaredDependencyNode,
                            message: 'Functions returned from `useEffectEvent` must not be included in the dependency array. ' +
                                `Remove \`${getSourceCode().getText(declaredDependencyNode)}\` from the list.`,
                            suggest: [
                                {
                                    desc: `Remove the dependency \`${getSourceCode().getText(declaredDependencyNode)}\``,
                                    fix(fixer) {
                                        return fixer.removeRange(declaredDependencyNode.range);
                                    },
                                },
                            ],
                        });
                    }
                    let declaredDependency;
                    try {
                        declaredDependency = analyzePropertyChain(declaredDependencyNode, null);
                    }
                    catch (error) {
                        if (error instanceof Error &&
                            /Unsupported node type/.test(error.message)) {
                            if (declaredDependencyNode.type === 'Literal') {
                                if (declaredDependencyNode.value &&
                                    dependencies.has(declaredDependencyNode.value)) {
                                    reportProblem({
                                        node: declaredDependencyNode,
                                        message: `The ${declaredDependencyNode.raw} literal is not a valid dependency ` +
                                            `because it never changes. ` +
                                            `Did you mean to include ${declaredDependencyNode.value} in the array instead?`,
                                    });
                                }
                                else {
                                    reportProblem({
                                        node: declaredDependencyNode,
                                        message: `The ${declaredDependencyNode.raw} literal is not a valid dependency ` +
                                            'because it never changes. You can safely remove it.',
                                    });
                                }
                            }
                            else {
                                reportProblem({
                                    node: declaredDependencyNode,
                                    message: `React Hook ${getSourceCode().getText(reactiveHook)} has a ` +
                                        `complex expression in the dependency array. ` +
                                        'Extract it to a separate variable so it can be statically checked.',
                                });
                            }
                            return;
                        }
                        else {
                            throw error;
                        }
                    }
                    let maybeID = declaredDependencyNode;
                    while (maybeID.type === 'MemberExpression' ||
                        maybeID.type === 'OptionalMemberExpression' ||
                        maybeID.type === 'ChainExpression') {
                        maybeID = maybeID.object || maybeID.expression.object;
                    }
                    const isDeclaredInComponent = !componentScope.through.some(ref => ref.identifier === maybeID);
                    declaredDependencies.push({
                        key: declaredDependency,
                        node: declaredDependencyNode,
                    });
                    if (!isDeclaredInComponent) {
                        externalDependencies.add(declaredDependency);
                    }
                });
            }
            const { suggestedDependencies, unnecessaryDependencies, missingDependencies, duplicateDependencies, } = collectRecommendations({
                dependencies,
                declaredDependencies,
                stableDependencies,
                externalDependencies,
                isEffect,
            });
            let suggestedDeps = suggestedDependencies;
            const problemCount = duplicateDependencies.size +
                missingDependencies.size +
                unnecessaryDependencies.size;
            if (problemCount === 0) {
                const constructions = scanForConstructions({
                    declaredDependencies,
                    declaredDependenciesNode,
                    componentScope,
                    scope,
                });
                constructions.forEach(({ construction, isUsedOutsideOfHook, depType }) => {
                    var _a;
                    const wrapperHook = depType === 'function' ? 'useCallback' : 'useMemo';
                    const constructionType = depType === 'function' ? 'definition' : 'initialization';
                    const defaultAdvice = `wrap the ${constructionType} of '${construction.name.name}' in its own ${wrapperHook}() Hook.`;
                    const advice = isUsedOutsideOfHook
                        ? `To fix this, ${defaultAdvice}`
                        : `Move it inside the ${reactiveHookName} callback. Alternatively, ${defaultAdvice}`;
                    const causation = depType === 'conditional' || depType === 'logical expression'
                        ? 'could make'
                        : 'makes';
                    const message = `The '${construction.name.name}' ${depType} ${causation} the dependencies of ` +
                        `${reactiveHookName} Hook (at line ${(_a = declaredDependenciesNode.loc) === null || _a === void 0 ? void 0 : _a.start.line}) ` +
                        `change on every render. ${advice}`;
                    let suggest;
                    if (isUsedOutsideOfHook &&
                        construction.type === 'Variable' &&
                        depType === 'function') {
                        suggest = [
                            {
                                desc: `Wrap the ${constructionType} of '${construction.name.name}' in its own ${wrapperHook}() Hook.`,
                                fix(fixer) {
                                    const [before, after] = wrapperHook === 'useMemo'
                                        ? [`useMemo(() => { return `, '; })']
                                        : ['useCallback(', ')'];
                                    return [
                                        fixer.insertTextBefore(construction.node.init, before),
                                        fixer.insertTextAfter(construction.node.init, after),
                                    ];
                                },
                            },
                        ];
                    }
                    reportProblem({
                        node: construction.node,
                        message,
                        suggest,
                    });
                });
                return;
            }
            if (!isEffect && missingDependencies.size > 0) {
                suggestedDeps = collectRecommendations({
                    dependencies,
                    declaredDependencies: [],
                    stableDependencies,
                    externalDependencies,
                    isEffect,
                }).suggestedDependencies;
            }
            function areDeclaredDepsAlphabetized() {
                if (declaredDependencies.length === 0) {
                    return true;
                }
                const declaredDepKeys = declaredDependencies.map(dep => dep.key);
                const sortedDeclaredDepKeys = declaredDepKeys.slice().sort();
                return declaredDepKeys.join(',') === sortedDeclaredDepKeys.join(',');
            }
            if (areDeclaredDepsAlphabetized()) {
                suggestedDeps.sort();
            }
            function formatDependency(path) {
                const members = path.split('.');
                let finalPath = '';
                for (let i = 0; i < members.length; i++) {
                    if (i !== 0) {
                        const pathSoFar = members.slice(0, i + 1).join('.');
                        const isOptional = optionalChains.get(pathSoFar) === true;
                        finalPath += isOptional ? '?.' : '.';
                    }
                    finalPath += members[i];
                }
                return finalPath;
            }
            function getWarningMessage(deps, singlePrefix, label, fixVerb) {
                if (deps.size === 0) {
                    return null;
                }
                return ((deps.size > 1 ? '' : singlePrefix + ' ') +
                    label +
                    ' ' +
                    (deps.size > 1 ? 'dependencies' : 'dependency') +
                    ': ' +
                    joinEnglish(Array.from(deps)
                        .sort()
                        .map(name => "'" + formatDependency(name) + "'")) +
                    `. Either ${fixVerb} ${deps.size > 1 ? 'them' : 'it'} or remove the dependency array.`);
            }
            let extraWarning = '';
            if (unnecessaryDependencies.size > 0) {
                let badRef = null;
                Array.from(unnecessaryDependencies.keys()).forEach(key => {
                    if (badRef !== null) {
                        return;
                    }
                    if (key.endsWith('.current')) {
                        badRef = key;
                    }
                });
                if (badRef !== null) {
                    extraWarning =
                        ` Mutable values like '${badRef}' aren't valid dependencies ` +
                            "because mutating them doesn't re-render the component.";
                }
                else if (externalDependencies.size > 0) {
                    const dep = Array.from(externalDependencies)[0];
                    if (!scope.set.has(dep)) {
                        extraWarning =
                            ` Outer scope values like '${dep}' aren't valid dependencies ` +
                                `because mutating them doesn't re-render the component.`;
                    }
                }
            }
            if (!extraWarning && missingDependencies.has('props')) {
                const propDep = dependencies.get('props');
                if (propDep == null) {
                    return;
                }
                const refs = propDep.references;
                if (!Array.isArray(refs)) {
                    return;
                }
                let isPropsOnlyUsedInMembers = true;
                for (const ref of refs) {
                    const id = fastFindReferenceWithParent(componentScope.block, ref.identifier);
                    if (!id) {
                        isPropsOnlyUsedInMembers = false;
                        break;
                    }
                    const parent = id.parent;
                    if (parent == null) {
                        isPropsOnlyUsedInMembers = false;
                        break;
                    }
                    if (parent.type !== 'MemberExpression' &&
                        parent.type !== 'OptionalMemberExpression') {
                        isPropsOnlyUsedInMembers = false;
                        break;
                    }
                }
                if (isPropsOnlyUsedInMembers) {
                    extraWarning =
                        ` However, 'props' will change when *any* prop changes, so the ` +
                            `preferred fix is to destructure the 'props' object outside of ` +
                            `the ${reactiveHookName} call and refer to those specific props ` +
                            `inside ${getSourceCode().getText(reactiveHook)}.`;
                }
            }
            if (!extraWarning && missingDependencies.size > 0) {
                let missingCallbackDep = null;
                missingDependencies.forEach(missingDep => {
                    var _a;
                    if (missingCallbackDep) {
                        return;
                    }
                    const topScopeRef = componentScope.set.get(missingDep);
                    const usedDep = dependencies.get(missingDep);
                    if (!(usedDep === null || usedDep === void 0 ? void 0 : usedDep.references) ||
                        ((_a = usedDep === null || usedDep === void 0 ? void 0 : usedDep.references[0]) === null || _a === void 0 ? void 0 : _a.resolved) !== topScopeRef) {
                        return;
                    }
                    const def = topScopeRef === null || topScopeRef === void 0 ? void 0 : topScopeRef.defs[0];
                    if (def == null || def.name == null || def.type !== 'Parameter') {
                        return;
                    }
                    let isFunctionCall = false;
                    let id;
                    for (const reference of usedDep.references) {
                        id = reference.identifier;
                        if (id != null &&
                            id.parent != null &&
                            (id.parent.type === 'CallExpression' ||
                                id.parent.type === 'OptionalCallExpression') &&
                            id.parent.callee === id) {
                            isFunctionCall = true;
                            break;
                        }
                    }
                    if (!isFunctionCall) {
                        return;
                    }
                    missingCallbackDep = missingDep;
                });
                if (missingCallbackDep !== null) {
                    extraWarning =
                        ` If '${missingCallbackDep}' changes too often, ` +
                            `find the parent component that defines it ` +
                            `and wrap that definition in useCallback.`;
                }
            }
            if (!extraWarning && missingDependencies.size > 0) {
                let setStateRecommendation = null;
                for (const missingDep of missingDependencies) {
                    if (setStateRecommendation !== null) {
                        break;
                    }
                    const usedDep = dependencies.get(missingDep);
                    const references = usedDep.references;
                    let id;
                    let maybeCall;
                    for (const reference of references) {
                        id = reference.identifier;
                        maybeCall = id.parent;
                        while (maybeCall != null && maybeCall !== componentScope.block) {
                            if (maybeCall.type === 'CallExpression') {
                                const correspondingStateVariable = setStateCallSites.get(maybeCall.callee);
                                if (correspondingStateVariable != null) {
                                    if ('name' in correspondingStateVariable &&
                                        correspondingStateVariable.name === missingDep) {
                                        setStateRecommendation = {
                                            missingDep,
                                            setter: 'name' in maybeCall.callee ? maybeCall.callee.name : '',
                                            form: 'updater',
                                        };
                                    }
                                    else if (stateVariables.has(id)) {
                                        setStateRecommendation = {
                                            missingDep,
                                            setter: 'name' in maybeCall.callee ? maybeCall.callee.name : '',
                                            form: 'reducer',
                                        };
                                    }
                                    else {
                                        const resolved = reference.resolved;
                                        if (resolved != null) {
                                            const def = resolved.defs[0];
                                            if (def != null && def.type === 'Parameter') {
                                                setStateRecommendation = {
                                                    missingDep,
                                                    setter: 'name' in maybeCall.callee
                                                        ? maybeCall.callee.name
                                                        : '',
                                                    form: 'inlineReducer',
                                                };
                                            }
                                        }
                                    }
                                    break;
                                }
                            }
                            maybeCall = maybeCall.parent;
                        }
                        if (setStateRecommendation !== null) {
                            break;
                        }
                    }
                }
                if (setStateRecommendation !== null) {
                    switch (setStateRecommendation.form) {
                        case 'reducer':
                            extraWarning =
                                ` You can also replace multiple useState variables with useReducer ` +
                                    `if '${setStateRecommendation.setter}' needs the ` +
                                    `current value of '${setStateRecommendation.missingDep}'.`;
                            break;
                        case 'inlineReducer':
                            extraWarning =
                                ` If '${setStateRecommendation.setter}' needs the ` +
                                    `current value of '${setStateRecommendation.missingDep}', ` +
                                    `you can also switch to useReducer instead of useState and ` +
                                    `read '${setStateRecommendation.missingDep}' in the reducer.`;
                            break;
                        case 'updater':
                            extraWarning =
                                ` You can also do a functional update '${setStateRecommendation.setter}(${setStateRecommendation.missingDep.slice(0, 1)} => ...)' if you only need '${setStateRecommendation.missingDep}'` + ` in the '${setStateRecommendation.setter}' call.`;
                            break;
                        default:
                            throw new Error('Unknown case.');
                    }
                }
            }
            reportProblem({
                node: declaredDependenciesNode,
                message: `React Hook ${getSourceCode().getText(reactiveHook)} has ` +
                    (getWarningMessage(missingDependencies, 'a', 'missing', 'include') ||
                        getWarningMessage(unnecessaryDependencies, 'an', 'unnecessary', 'exclude') ||
                        getWarningMessage(duplicateDependencies, 'a', 'duplicate', 'omit')) +
                    extraWarning,
                suggest: [
                    {
                        desc: `Update the dependencies array to be: [${suggestedDeps
                            .map(formatDependency)
                            .join(', ')}]`,
                        fix(fixer) {
                            return fixer.replaceText(declaredDependenciesNode, `[${suggestedDeps.map(formatDependency).join(', ')}]`);
                        },
                    },
                ],
            });
        }
        function visitCallExpression(node) {
            const callbackIndex = getReactiveHookCallbackIndex(node.callee, options);
            if (callbackIndex === -1) {
                return;
            }
            let callback = node.arguments[callbackIndex];
            const reactiveHook = node.callee;
            const nodeWithoutNamespace = getNodeWithoutReactNamespace$1(reactiveHook);
            const reactiveHookName = 'name' in nodeWithoutNamespace ? nodeWithoutNamespace.name : '';
            const maybeNode = node.arguments[callbackIndex + 1];
            const declaredDependenciesNode = maybeNode &&
                !(maybeNode.type === 'Identifier' && maybeNode.name === 'undefined')
                ? maybeNode
                : undefined;
            const isEffect = /Effect($|[^a-z])/g.test(reactiveHookName);
            if (!callback) {
                reportProblem({
                    node: reactiveHook,
                    message: `React Hook ${reactiveHookName} requires an effect callback. ` +
                        `Did you forget to pass a callback to the hook?`,
                });
                return;
            }
            if (!maybeNode && isEffect && options.requireExplicitEffectDeps) {
                reportProblem({
                    node: reactiveHook,
                    message: `React Hook ${reactiveHookName} always requires dependencies. ` +
                        `Please add a dependency array or an explicit \`undefined\``,
                });
            }
            const isAutoDepsHook = options.experimental_autoDependenciesHooks.includes(reactiveHookName);
            if ((!declaredDependenciesNode ||
                (isAutoDepsHook &&
                    declaredDependenciesNode.type === 'Literal' &&
                    declaredDependenciesNode.value === null)) &&
                !isEffect) {
                if (reactiveHookName === 'useMemo' ||
                    reactiveHookName === 'useCallback') {
                    reportProblem({
                        node: reactiveHook,
                        message: `React Hook ${reactiveHookName} does nothing when called with ` +
                            `only one argument. Did you forget to pass an array of ` +
                            `dependencies?`,
                    });
                }
                return;
            }
            while (callback.type === 'TSAsExpression' ||
                callback.type === 'AsExpression') {
                callback = callback.expression;
            }
            switch (callback.type) {
                case 'FunctionExpression':
                case 'ArrowFunctionExpression':
                    visitFunctionWithDependencies(callback, declaredDependenciesNode, reactiveHook, reactiveHookName, isEffect, isAutoDepsHook);
                    return;
                case 'Identifier':
                    if (!declaredDependenciesNode ||
                        (isAutoDepsHook &&
                            declaredDependenciesNode.type === 'Literal' &&
                            declaredDependenciesNode.value === null)) {
                        return;
                    }
                    if ('elements' in declaredDependenciesNode &&
                        declaredDependenciesNode.elements &&
                        declaredDependenciesNode.elements.some(el => el && el.type === 'Identifier' && el.name === callback.name)) {
                        return;
                    }
                    const variable = getScope(callback).set.get(callback.name);
                    if (variable == null || variable.defs == null) {
                        return;
                    }
                    const def = variable.defs[0];
                    if (!def || !def.node) {
                        break;
                    }
                    if (def.type === 'Parameter') {
                        reportProblem({
                            node: reactiveHook,
                            message: getUnknownDependenciesMessage(reactiveHookName),
                        });
                        return;
                    }
                    if (def.type !== 'Variable' && def.type !== 'FunctionName') {
                        break;
                    }
                    switch (def.node.type) {
                        case 'FunctionDeclaration':
                            visitFunctionWithDependencies(def.node, declaredDependenciesNode, reactiveHook, reactiveHookName, isEffect, isAutoDepsHook);
                            return;
                        case 'VariableDeclarator':
                            const init = def.node.init;
                            if (!init) {
                                break;
                            }
                            switch (init.type) {
                                case 'ArrowFunctionExpression':
                                case 'FunctionExpression':
                                    visitFunctionWithDependencies(init, declaredDependenciesNode, reactiveHook, reactiveHookName, isEffect, isAutoDepsHook);
                                    return;
                            }
                            break;
                    }
                    break;
                default:
                    reportProblem({
                        node: reactiveHook,
                        message: getUnknownDependenciesMessage(reactiveHookName),
                    });
                    return;
            }
            reportProblem({
                node: reactiveHook,
                message: `React Hook ${reactiveHookName} has a missing dependency: '${callback.name}'. ` +
                    `Either include it or remove the dependency array.`,
                suggest: [
                    {
                        desc: `Update the dependencies array to be: [${callback.name}]`,
                        fix(fixer) {
                            return fixer.replaceText(declaredDependenciesNode, `[${callback.name}]`);
                        },
                    },
                ],
            });
        }
        return {
            CallExpression: visitCallExpression,
        };
    },
};
function collectRecommendations({ dependencies, declaredDependencies, stableDependencies, externalDependencies, isEffect, }) {
    const depTree = createDepTree();
    function createDepTree() {
        return {
            isUsed: false,
            isSatisfiedRecursively: false,
            isSubtreeUsed: false,
            children: new Map(),
        };
    }
    dependencies.forEach((_, key) => {
        const node = getOrCreateNodeByPath(depTree, key);
        node.isUsed = true;
        markAllParentsByPath(depTree, key, parent => {
            parent.isSubtreeUsed = true;
        });
    });
    declaredDependencies.forEach(({ key }) => {
        const node = getOrCreateNodeByPath(depTree, key);
        node.isSatisfiedRecursively = true;
    });
    stableDependencies.forEach(key => {
        const node = getOrCreateNodeByPath(depTree, key);
        node.isSatisfiedRecursively = true;
    });
    function getOrCreateNodeByPath(rootNode, path) {
        const keys = path.split('.');
        let node = rootNode;
        for (const key of keys) {
            let child = node.children.get(key);
            if (!child) {
                child = createDepTree();
                node.children.set(key, child);
            }
            node = child;
        }
        return node;
    }
    function markAllParentsByPath(rootNode, path, fn) {
        const keys = path.split('.');
        let node = rootNode;
        for (const key of keys) {
            const child = node.children.get(key);
            if (!child) {
                return;
            }
            fn(child);
            node = child;
        }
    }
    const missingDependencies = new Set();
    const satisfyingDependencies = new Set();
    scanTreeRecursively(depTree, missingDependencies, satisfyingDependencies, key => key);
    function scanTreeRecursively(node, missingPaths, satisfyingPaths, keyToPath) {
        node.children.forEach((child, key) => {
            const path = keyToPath(key);
            if (child.isSatisfiedRecursively) {
                if (child.isSubtreeUsed) {
                    satisfyingPaths.add(path);
                }
                return;
            }
            if (child.isUsed) {
                missingPaths.add(path);
                return;
            }
            scanTreeRecursively(child, missingPaths, satisfyingPaths, childKey => path + '.' + childKey);
        });
    }
    const suggestedDependencies = [];
    const unnecessaryDependencies = new Set();
    const duplicateDependencies = new Set();
    declaredDependencies.forEach(({ key }) => {
        if (satisfyingDependencies.has(key)) {
            if (suggestedDependencies.indexOf(key) === -1) {
                suggestedDependencies.push(key);
            }
            else {
                duplicateDependencies.add(key);
            }
        }
        else {
            if (isEffect &&
                !key.endsWith('.current') &&
                !externalDependencies.has(key)) {
                if (suggestedDependencies.indexOf(key) === -1) {
                    suggestedDependencies.push(key);
                }
            }
            else {
                unnecessaryDependencies.add(key);
            }
        }
    });
    missingDependencies.forEach(key => {
        suggestedDependencies.push(key);
    });
    return {
        suggestedDependencies,
        unnecessaryDependencies,
        duplicateDependencies,
        missingDependencies,
    };
}
function getConstructionExpressionType(node) {
    switch (node.type) {
        case 'ObjectExpression':
            return 'object';
        case 'ArrayExpression':
            return 'array';
        case 'ArrowFunctionExpression':
        case 'FunctionExpression':
            return 'function';
        case 'ClassExpression':
            return 'class';
        case 'ConditionalExpression':
            if (getConstructionExpressionType(node.consequent) != null ||
                getConstructionExpressionType(node.alternate) != null) {
                return 'conditional';
            }
            return null;
        case 'LogicalExpression':
            if (getConstructionExpressionType(node.left) != null ||
                getConstructionExpressionType(node.right) != null) {
                return 'logical expression';
            }
            return null;
        case 'JSXFragment':
            return 'JSX fragment';
        case 'JSXElement':
            return 'JSX element';
        case 'AssignmentExpression':
            if (getConstructionExpressionType(node.right) != null) {
                return 'assignment expression';
            }
            return null;
        case 'NewExpression':
            return 'object construction';
        case 'Literal':
            if (node.value instanceof RegExp) {
                return 'regular expression';
            }
            return null;
        case 'TypeCastExpression':
        case 'AsExpression':
        case 'TSAsExpression':
            return getConstructionExpressionType(node.expression);
    }
    return null;
}
function scanForConstructions({ declaredDependencies, declaredDependenciesNode, componentScope, scope, }) {
    const constructions = declaredDependencies
        .map(({ key }) => {
        const ref = componentScope.variables.find(v => v.name === key);
        if (ref == null) {
            return null;
        }
        const node = ref.defs[0];
        if (node == null) {
            return null;
        }
        if (node.type === 'Variable' &&
            node.node.type === 'VariableDeclarator' &&
            node.node.id.type === 'Identifier' &&
            node.node.init != null) {
            const constantExpressionType = getConstructionExpressionType(node.node.init);
            if (constantExpressionType) {
                return [ref, constantExpressionType];
            }
        }
        if (node.type === 'FunctionName' &&
            node.node.type === 'FunctionDeclaration') {
            return [ref, 'function'];
        }
        if (node.type === 'ClassName' && node.node.type === 'ClassDeclaration') {
            return [ref, 'class'];
        }
        return null;
    })
        .filter(Boolean);
    function isUsedOutsideOfHook(ref) {
        let foundWriteExpr = false;
        for (const reference of ref.references) {
            if (reference.writeExpr) {
                if (foundWriteExpr) {
                    return true;
                }
                else {
                    foundWriteExpr = true;
                    continue;
                }
            }
            let currentScope = reference.from;
            while (currentScope !== scope && currentScope != null) {
                currentScope = currentScope.upper;
            }
            if (currentScope !== scope) {
                if (!isAncestorNodeOf(declaredDependenciesNode, reference.identifier)) {
                    return true;
                }
            }
        }
        return false;
    }
    return constructions.map(([ref, depType]) => ({
        construction: ref.defs[0],
        depType,
        isUsedOutsideOfHook: isUsedOutsideOfHook(ref),
    }));
}
function getDependency(node) {
    if (node.parent &&
        (node.parent.type === 'MemberExpression' ||
            node.parent.type === 'OptionalMemberExpression') &&
        node.parent.object === node &&
        'name' in node.parent.property &&
        node.parent.property.name !== 'current' &&
        !node.parent.computed &&
        !(node.parent.parent != null &&
            (node.parent.parent.type === 'CallExpression' ||
                node.parent.parent.type === 'OptionalCallExpression') &&
            node.parent.parent.callee === node.parent)) {
        return getDependency(node.parent);
    }
    else if (node.type === 'MemberExpression' &&
        node.parent &&
        node.parent.type === 'AssignmentExpression' &&
        node.parent.left === node) {
        return node.object;
    }
    else {
        return node;
    }
}
function markNode(node, optionalChains, result) {
    if (optionalChains) {
        if ('optional' in node && node.optional) {
            if (!optionalChains.has(result)) {
                optionalChains.set(result, true);
            }
        }
        else {
            optionalChains.set(result, false);
        }
    }
}
function analyzePropertyChain(node, optionalChains) {
    if (node.type === 'Identifier' || node.type === 'JSXIdentifier') {
        const result = node.name;
        if (optionalChains) {
            optionalChains.set(result, false);
        }
        return result;
    }
    else if (node.type === 'MemberExpression' && !node.computed) {
        const object = analyzePropertyChain(node.object, optionalChains);
        const property = analyzePropertyChain(node.property, null);
        const result = `${object}.${property}`;
        markNode(node, optionalChains, result);
        return result;
    }
    else if (node.type === 'OptionalMemberExpression' && !node.computed) {
        const object = analyzePropertyChain(node.object, optionalChains);
        const property = analyzePropertyChain(node.property, null);
        const result = `${object}.${property}`;
        markNode(node, optionalChains, result);
        return result;
    }
    else if (node.type === 'ChainExpression' &&
        (!('computed' in node) || !node.computed)) {
        const expression = node.expression;
        if (expression.type === 'CallExpression') {
            throw new Error(`Unsupported node type: ${expression.type}`);
        }
        const object = analyzePropertyChain(expression.object, optionalChains);
        const property = analyzePropertyChain(expression.property, null);
        const result = `${object}.${property}`;
        markNode(expression, optionalChains, result);
        return result;
    }
    else {
        throw new Error(`Unsupported node type: ${node.type}`);
    }
}
function getNodeWithoutReactNamespace$1(node) {
    if (node.type === 'MemberExpression' &&
        node.object.type === 'Identifier' &&
        node.object.name === 'React' &&
        node.property.type === 'Identifier' &&
        !node.computed) {
        return node.property;
    }
    return node;
}
function getReactiveHookCallbackIndex(calleeNode, options) {
    const node = getNodeWithoutReactNamespace$1(calleeNode);
    if (node.type !== 'Identifier') {
        return -1;
    }
    switch (node.name) {
        case 'useEffect':
        case 'useLayoutEffect':
        case 'useCallback':
        case 'useMemo':
            return 0;
        case 'useImperativeHandle':
            return 1;
        default:
            if (node === calleeNode && options && options.additionalHooks) {
                let name;
                try {
                    name = analyzePropertyChain(node, null);
                }
                catch (error) {
                    if (error instanceof Error &&
                        /Unsupported node type/.test(error.message)) {
                        return 0;
                    }
                    else {
                        throw error;
                    }
                }
                return options.additionalHooks.test(name) ? 0 : -1;
            }
            else {
                return -1;
            }
    }
}
function fastFindReferenceWithParent(start, target) {
    const queue = [start];
    let item;
    while (queue.length) {
        item = queue.shift();
        if (isSameIdentifier(item, target)) {
            return item;
        }
        if (!isAncestorNodeOf(item, target)) {
            continue;
        }
        for (const [key, value] of Object.entries(item)) {
            if (key === 'parent') {
                continue;
            }
            if (isNodeLike(value)) {
                value.parent = item;
                queue.push(value);
            }
            else if (Array.isArray(value)) {
                value.forEach(val => {
                    if (isNodeLike(val)) {
                        val.parent = item;
                        queue.push(val);
                    }
                });
            }
        }
    }
    return null;
}
function joinEnglish(arr) {
    let s = '';
    for (let i = 0; i < arr.length; i++) {
        s += arr[i];
        if (i === 0 && arr.length === 2) {
            s += ' and ';
        }
        else if (i === arr.length - 2 && arr.length > 2) {
            s += ', and ';
        }
        else if (i < arr.length - 1) {
            s += ', ';
        }
    }
    return s;
}
function isNodeLike(val) {
    return (typeof val === 'object' &&
        val !== null &&
        !Array.isArray(val) &&
        'type' in val &&
        typeof val.type === 'string');
}
function isSameIdentifier(a, b) {
    return ((a.type === 'Identifier' || a.type === 'JSXIdentifier') &&
        a.type === b.type &&
        a.name === b.name &&
        !!a.range &&
        !!b.range &&
        a.range[0] === b.range[0] &&
        a.range[1] === b.range[1]);
}
function isAncestorNodeOf(a, b) {
    return (!!a.range &&
        !!b.range &&
        a.range[0] <= b.range[0] &&
        a.range[1] >= b.range[1]);
}
function isUseEffectEventIdentifier$1(node) {
    return node.type === 'Identifier' && node.name === 'useEffectEvent';
}
function getUnknownDependenciesMessage(reactiveHookName) {
    return (`React Hook ${reactiveHookName} received a function whose dependencies ` +
        `are unknown. Pass an inline function instead.`);
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var invariant_1;
var hasRequiredInvariant;

function requireInvariant () {
	if (hasRequiredInvariant) return invariant_1;
	hasRequiredInvariant = 1;

	var invariant = function(condition, format, a, b, c, d, e, f) {
	  {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }

	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error(
	        'Minified exception occurred; use the non-minified dev environment ' +
	        'for the full error message and additional helpful warnings.'
	      );
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(
	        format.replace(/%s/g, function() { return args[argIndex++]; })
	      );
	      error.name = 'Invariant Violation';
	    }

	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};

	invariant_1 = invariant;
	return invariant_1;
}

var invariantExports = requireInvariant();
var invariant = /*@__PURE__*/getDefaultExportFromCjs(invariantExports);

var lib$3 = {};

var isReactComponent = {};

var buildMatchMemberExpression = {};

var matchesPattern = {};

var generated$3 = {};

var shallowEqual = {};

var hasRequiredShallowEqual;

function requireShallowEqual () {
	if (hasRequiredShallowEqual) return shallowEqual;
	hasRequiredShallowEqual = 1;

	Object.defineProperty(shallowEqual, "__esModule", {
	  value: true
	});
	shallowEqual.default = shallowEqual$1;
	function shallowEqual$1(actual, expected) {
	  const keys = Object.keys(expected);
	  for (const key of keys) {
	    if (actual[key] !== expected[key]) {
	      return false;
	    }
	  }
	  return true;
	}

	
	return shallowEqual;
}

var deprecationWarning = {};

var hasRequiredDeprecationWarning;

function requireDeprecationWarning () {
	if (hasRequiredDeprecationWarning) return deprecationWarning;
	hasRequiredDeprecationWarning = 1;

	Object.defineProperty(deprecationWarning, "__esModule", {
	  value: true
	});
	deprecationWarning.default = deprecationWarning$1;
	const warnings = new Set();
	function deprecationWarning$1(oldName, newName, prefix = "") {
	  if (warnings.has(oldName)) return;
	  warnings.add(oldName);
	  const {
	    internal,
	    trace
	  } = captureShortStackTrace(1, 2);
	  if (internal) {
	    return;
	  }
	  console.warn(`${prefix}\`${oldName}\` has been deprecated, please migrate to \`${newName}\`\n${trace}`);
	}
	function captureShortStackTrace(skip, length) {
	  const {
	    stackTraceLimit,
	    prepareStackTrace
	  } = Error;
	  let stackTrace;
	  Error.stackTraceLimit = 1 + skip + length;
	  Error.prepareStackTrace = function (err, stack) {
	    stackTrace = stack;
	  };
	  Error.stackTraceLimit = stackTraceLimit;
	  Error.prepareStackTrace = prepareStackTrace;
	  if (!stackTrace) return {
	    internal: false,
	    trace: ""
	  };
	  const shortStackTrace = stackTrace.slice(1 + skip, 1 + skip + length);
	  return {
	    internal: /[\\/]@babel[\\/]/.test(shortStackTrace[1].getFileName()),
	    trace: shortStackTrace.map(frame => `    at ${frame}`).join("\n")
	  };
	}

	
	return deprecationWarning;
}

var hasRequiredGenerated$3;

function requireGenerated$3 () {
	if (hasRequiredGenerated$3) return generated$3;
	hasRequiredGenerated$3 = 1;

	Object.defineProperty(generated$3, "__esModule", {
	  value: true
	});
	generated$3.isAccessor = isAccessor;
	generated$3.isAnyTypeAnnotation = isAnyTypeAnnotation;
	generated$3.isArgumentPlaceholder = isArgumentPlaceholder;
	generated$3.isArrayExpression = isArrayExpression;
	generated$3.isArrayPattern = isArrayPattern;
	generated$3.isArrayTypeAnnotation = isArrayTypeAnnotation;
	generated$3.isArrowFunctionExpression = isArrowFunctionExpression;
	generated$3.isAssignmentExpression = isAssignmentExpression;
	generated$3.isAssignmentPattern = isAssignmentPattern;
	generated$3.isAwaitExpression = isAwaitExpression;
	generated$3.isBigIntLiteral = isBigIntLiteral;
	generated$3.isBinary = isBinary;
	generated$3.isBinaryExpression = isBinaryExpression;
	generated$3.isBindExpression = isBindExpression;
	generated$3.isBlock = isBlock;
	generated$3.isBlockParent = isBlockParent;
	generated$3.isBlockStatement = isBlockStatement;
	generated$3.isBooleanLiteral = isBooleanLiteral;
	generated$3.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
	generated$3.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
	generated$3.isBreakStatement = isBreakStatement;
	generated$3.isCallExpression = isCallExpression;
	generated$3.isCatchClause = isCatchClause;
	generated$3.isClass = isClass;
	generated$3.isClassAccessorProperty = isClassAccessorProperty;
	generated$3.isClassBody = isClassBody;
	generated$3.isClassDeclaration = isClassDeclaration;
	generated$3.isClassExpression = isClassExpression;
	generated$3.isClassImplements = isClassImplements;
	generated$3.isClassMethod = isClassMethod;
	generated$3.isClassPrivateMethod = isClassPrivateMethod;
	generated$3.isClassPrivateProperty = isClassPrivateProperty;
	generated$3.isClassProperty = isClassProperty;
	generated$3.isCompletionStatement = isCompletionStatement;
	generated$3.isConditional = isConditional;
	generated$3.isConditionalExpression = isConditionalExpression;
	generated$3.isContinueStatement = isContinueStatement;
	generated$3.isDebuggerStatement = isDebuggerStatement;
	generated$3.isDecimalLiteral = isDecimalLiteral;
	generated$3.isDeclaration = isDeclaration;
	generated$3.isDeclareClass = isDeclareClass;
	generated$3.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
	generated$3.isDeclareExportDeclaration = isDeclareExportDeclaration;
	generated$3.isDeclareFunction = isDeclareFunction;
	generated$3.isDeclareInterface = isDeclareInterface;
	generated$3.isDeclareModule = isDeclareModule;
	generated$3.isDeclareModuleExports = isDeclareModuleExports;
	generated$3.isDeclareOpaqueType = isDeclareOpaqueType;
	generated$3.isDeclareTypeAlias = isDeclareTypeAlias;
	generated$3.isDeclareVariable = isDeclareVariable;
	generated$3.isDeclaredPredicate = isDeclaredPredicate;
	generated$3.isDecorator = isDecorator;
	generated$3.isDirective = isDirective;
	generated$3.isDirectiveLiteral = isDirectiveLiteral;
	generated$3.isDoExpression = isDoExpression;
	generated$3.isDoWhileStatement = isDoWhileStatement;
	generated$3.isEmptyStatement = isEmptyStatement;
	generated$3.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
	generated$3.isEnumBody = isEnumBody;
	generated$3.isEnumBooleanBody = isEnumBooleanBody;
	generated$3.isEnumBooleanMember = isEnumBooleanMember;
	generated$3.isEnumDeclaration = isEnumDeclaration;
	generated$3.isEnumDefaultedMember = isEnumDefaultedMember;
	generated$3.isEnumMember = isEnumMember;
	generated$3.isEnumNumberBody = isEnumNumberBody;
	generated$3.isEnumNumberMember = isEnumNumberMember;
	generated$3.isEnumStringBody = isEnumStringBody;
	generated$3.isEnumStringMember = isEnumStringMember;
	generated$3.isEnumSymbolBody = isEnumSymbolBody;
	generated$3.isExistsTypeAnnotation = isExistsTypeAnnotation;
	generated$3.isExportAllDeclaration = isExportAllDeclaration;
	generated$3.isExportDeclaration = isExportDeclaration;
	generated$3.isExportDefaultDeclaration = isExportDefaultDeclaration;
	generated$3.isExportDefaultSpecifier = isExportDefaultSpecifier;
	generated$3.isExportNamedDeclaration = isExportNamedDeclaration;
	generated$3.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
	generated$3.isExportSpecifier = isExportSpecifier;
	generated$3.isExpression = isExpression;
	generated$3.isExpressionStatement = isExpressionStatement;
	generated$3.isExpressionWrapper = isExpressionWrapper;
	generated$3.isFile = isFile;
	generated$3.isFlow = isFlow;
	generated$3.isFlowBaseAnnotation = isFlowBaseAnnotation;
	generated$3.isFlowDeclaration = isFlowDeclaration;
	generated$3.isFlowPredicate = isFlowPredicate;
	generated$3.isFlowType = isFlowType;
	generated$3.isFor = isFor;
	generated$3.isForInStatement = isForInStatement;
	generated$3.isForOfStatement = isForOfStatement;
	generated$3.isForStatement = isForStatement;
	generated$3.isForXStatement = isForXStatement;
	generated$3.isFunction = isFunction;
	generated$3.isFunctionDeclaration = isFunctionDeclaration;
	generated$3.isFunctionExpression = isFunctionExpression;
	generated$3.isFunctionParent = isFunctionParent;
	generated$3.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
	generated$3.isFunctionTypeParam = isFunctionTypeParam;
	generated$3.isGenericTypeAnnotation = isGenericTypeAnnotation;
	generated$3.isIdentifier = isIdentifier;
	generated$3.isIfStatement = isIfStatement;
	generated$3.isImmutable = isImmutable;
	generated$3.isImport = isImport;
	generated$3.isImportAttribute = isImportAttribute;
	generated$3.isImportDeclaration = isImportDeclaration;
	generated$3.isImportDefaultSpecifier = isImportDefaultSpecifier;
	generated$3.isImportExpression = isImportExpression;
	generated$3.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
	generated$3.isImportOrExportDeclaration = isImportOrExportDeclaration;
	generated$3.isImportSpecifier = isImportSpecifier;
	generated$3.isIndexedAccessType = isIndexedAccessType;
	generated$3.isInferredPredicate = isInferredPredicate;
	generated$3.isInterfaceDeclaration = isInterfaceDeclaration;
	generated$3.isInterfaceExtends = isInterfaceExtends;
	generated$3.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
	generated$3.isInterpreterDirective = isInterpreterDirective;
	generated$3.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
	generated$3.isJSX = isJSX;
	generated$3.isJSXAttribute = isJSXAttribute;
	generated$3.isJSXClosingElement = isJSXClosingElement;
	generated$3.isJSXClosingFragment = isJSXClosingFragment;
	generated$3.isJSXElement = isJSXElement;
	generated$3.isJSXEmptyExpression = isJSXEmptyExpression;
	generated$3.isJSXExpressionContainer = isJSXExpressionContainer;
	generated$3.isJSXFragment = isJSXFragment;
	generated$3.isJSXIdentifier = isJSXIdentifier;
	generated$3.isJSXMemberExpression = isJSXMemberExpression;
	generated$3.isJSXNamespacedName = isJSXNamespacedName;
	generated$3.isJSXOpeningElement = isJSXOpeningElement;
	generated$3.isJSXOpeningFragment = isJSXOpeningFragment;
	generated$3.isJSXSpreadAttribute = isJSXSpreadAttribute;
	generated$3.isJSXSpreadChild = isJSXSpreadChild;
	generated$3.isJSXText = isJSXText;
	generated$3.isLVal = isLVal;
	generated$3.isLabeledStatement = isLabeledStatement;
	generated$3.isLiteral = isLiteral;
	generated$3.isLogicalExpression = isLogicalExpression;
	generated$3.isLoop = isLoop;
	generated$3.isMemberExpression = isMemberExpression;
	generated$3.isMetaProperty = isMetaProperty;
	generated$3.isMethod = isMethod;
	generated$3.isMiscellaneous = isMiscellaneous;
	generated$3.isMixedTypeAnnotation = isMixedTypeAnnotation;
	generated$3.isModuleDeclaration = isModuleDeclaration;
	generated$3.isModuleExpression = isModuleExpression;
	generated$3.isModuleSpecifier = isModuleSpecifier;
	generated$3.isNewExpression = isNewExpression;
	generated$3.isNoop = isNoop;
	generated$3.isNullLiteral = isNullLiteral;
	generated$3.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
	generated$3.isNullableTypeAnnotation = isNullableTypeAnnotation;
	generated$3.isNumberLiteral = isNumberLiteral;
	generated$3.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
	generated$3.isNumberTypeAnnotation = isNumberTypeAnnotation;
	generated$3.isNumericLiteral = isNumericLiteral;
	generated$3.isObjectExpression = isObjectExpression;
	generated$3.isObjectMember = isObjectMember;
	generated$3.isObjectMethod = isObjectMethod;
	generated$3.isObjectPattern = isObjectPattern;
	generated$3.isObjectProperty = isObjectProperty;
	generated$3.isObjectTypeAnnotation = isObjectTypeAnnotation;
	generated$3.isObjectTypeCallProperty = isObjectTypeCallProperty;
	generated$3.isObjectTypeIndexer = isObjectTypeIndexer;
	generated$3.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
	generated$3.isObjectTypeProperty = isObjectTypeProperty;
	generated$3.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
	generated$3.isOpaqueType = isOpaqueType;
	generated$3.isOptionalCallExpression = isOptionalCallExpression;
	generated$3.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
	generated$3.isOptionalMemberExpression = isOptionalMemberExpression;
	generated$3.isParenthesizedExpression = isParenthesizedExpression;
	generated$3.isPattern = isPattern;
	generated$3.isPatternLike = isPatternLike;
	generated$3.isPipelineBareFunction = isPipelineBareFunction;
	generated$3.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
	generated$3.isPipelineTopicExpression = isPipelineTopicExpression;
	generated$3.isPlaceholder = isPlaceholder;
	generated$3.isPrivate = isPrivate;
	generated$3.isPrivateName = isPrivateName;
	generated$3.isProgram = isProgram;
	generated$3.isProperty = isProperty;
	generated$3.isPureish = isPureish;
	generated$3.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
	generated$3.isRecordExpression = isRecordExpression;
	generated$3.isRegExpLiteral = isRegExpLiteral;
	generated$3.isRegexLiteral = isRegexLiteral;
	generated$3.isRestElement = isRestElement;
	generated$3.isRestProperty = isRestProperty;
	generated$3.isReturnStatement = isReturnStatement;
	generated$3.isScopable = isScopable;
	generated$3.isSequenceExpression = isSequenceExpression;
	generated$3.isSpreadElement = isSpreadElement;
	generated$3.isSpreadProperty = isSpreadProperty;
	generated$3.isStandardized = isStandardized;
	generated$3.isStatement = isStatement;
	generated$3.isStaticBlock = isStaticBlock;
	generated$3.isStringLiteral = isStringLiteral;
	generated$3.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
	generated$3.isStringTypeAnnotation = isStringTypeAnnotation;
	generated$3.isSuper = isSuper;
	generated$3.isSwitchCase = isSwitchCase;
	generated$3.isSwitchStatement = isSwitchStatement;
	generated$3.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
	generated$3.isTSAnyKeyword = isTSAnyKeyword;
	generated$3.isTSArrayType = isTSArrayType;
	generated$3.isTSAsExpression = isTSAsExpression;
	generated$3.isTSBaseType = isTSBaseType;
	generated$3.isTSBigIntKeyword = isTSBigIntKeyword;
	generated$3.isTSBooleanKeyword = isTSBooleanKeyword;
	generated$3.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
	generated$3.isTSConditionalType = isTSConditionalType;
	generated$3.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
	generated$3.isTSConstructorType = isTSConstructorType;
	generated$3.isTSDeclareFunction = isTSDeclareFunction;
	generated$3.isTSDeclareMethod = isTSDeclareMethod;
	generated$3.isTSEntityName = isTSEntityName;
	generated$3.isTSEnumDeclaration = isTSEnumDeclaration;
	generated$3.isTSEnumMember = isTSEnumMember;
	generated$3.isTSExportAssignment = isTSExportAssignment;
	generated$3.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
	generated$3.isTSExternalModuleReference = isTSExternalModuleReference;
	generated$3.isTSFunctionType = isTSFunctionType;
	generated$3.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
	generated$3.isTSImportType = isTSImportType;
	generated$3.isTSIndexSignature = isTSIndexSignature;
	generated$3.isTSIndexedAccessType = isTSIndexedAccessType;
	generated$3.isTSInferType = isTSInferType;
	generated$3.isTSInstantiationExpression = isTSInstantiationExpression;
	generated$3.isTSInterfaceBody = isTSInterfaceBody;
	generated$3.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
	generated$3.isTSIntersectionType = isTSIntersectionType;
	generated$3.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
	generated$3.isTSLiteralType = isTSLiteralType;
	generated$3.isTSMappedType = isTSMappedType;
	generated$3.isTSMethodSignature = isTSMethodSignature;
	generated$3.isTSModuleBlock = isTSModuleBlock;
	generated$3.isTSModuleDeclaration = isTSModuleDeclaration;
	generated$3.isTSNamedTupleMember = isTSNamedTupleMember;
	generated$3.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
	generated$3.isTSNeverKeyword = isTSNeverKeyword;
	generated$3.isTSNonNullExpression = isTSNonNullExpression;
	generated$3.isTSNullKeyword = isTSNullKeyword;
	generated$3.isTSNumberKeyword = isTSNumberKeyword;
	generated$3.isTSObjectKeyword = isTSObjectKeyword;
	generated$3.isTSOptionalType = isTSOptionalType;
	generated$3.isTSParameterProperty = isTSParameterProperty;
	generated$3.isTSParenthesizedType = isTSParenthesizedType;
	generated$3.isTSPropertySignature = isTSPropertySignature;
	generated$3.isTSQualifiedName = isTSQualifiedName;
	generated$3.isTSRestType = isTSRestType;
	generated$3.isTSSatisfiesExpression = isTSSatisfiesExpression;
	generated$3.isTSStringKeyword = isTSStringKeyword;
	generated$3.isTSSymbolKeyword = isTSSymbolKeyword;
	generated$3.isTSThisType = isTSThisType;
	generated$3.isTSTupleType = isTSTupleType;
	generated$3.isTSType = isTSType;
	generated$3.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
	generated$3.isTSTypeAnnotation = isTSTypeAnnotation;
	generated$3.isTSTypeAssertion = isTSTypeAssertion;
	generated$3.isTSTypeElement = isTSTypeElement;
	generated$3.isTSTypeLiteral = isTSTypeLiteral;
	generated$3.isTSTypeOperator = isTSTypeOperator;
	generated$3.isTSTypeParameter = isTSTypeParameter;
	generated$3.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
	generated$3.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
	generated$3.isTSTypePredicate = isTSTypePredicate;
	generated$3.isTSTypeQuery = isTSTypeQuery;
	generated$3.isTSTypeReference = isTSTypeReference;
	generated$3.isTSUndefinedKeyword = isTSUndefinedKeyword;
	generated$3.isTSUnionType = isTSUnionType;
	generated$3.isTSUnknownKeyword = isTSUnknownKeyword;
	generated$3.isTSVoidKeyword = isTSVoidKeyword;
	generated$3.isTaggedTemplateExpression = isTaggedTemplateExpression;
	generated$3.isTemplateElement = isTemplateElement;
	generated$3.isTemplateLiteral = isTemplateLiteral;
	generated$3.isTerminatorless = isTerminatorless;
	generated$3.isThisExpression = isThisExpression;
	generated$3.isThisTypeAnnotation = isThisTypeAnnotation;
	generated$3.isThrowStatement = isThrowStatement;
	generated$3.isTopicReference = isTopicReference;
	generated$3.isTryStatement = isTryStatement;
	generated$3.isTupleExpression = isTupleExpression;
	generated$3.isTupleTypeAnnotation = isTupleTypeAnnotation;
	generated$3.isTypeAlias = isTypeAlias;
	generated$3.isTypeAnnotation = isTypeAnnotation;
	generated$3.isTypeCastExpression = isTypeCastExpression;
	generated$3.isTypeParameter = isTypeParameter;
	generated$3.isTypeParameterDeclaration = isTypeParameterDeclaration;
	generated$3.isTypeParameterInstantiation = isTypeParameterInstantiation;
	generated$3.isTypeScript = isTypeScript;
	generated$3.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
	generated$3.isUnaryExpression = isUnaryExpression;
	generated$3.isUnaryLike = isUnaryLike;
	generated$3.isUnionTypeAnnotation = isUnionTypeAnnotation;
	generated$3.isUpdateExpression = isUpdateExpression;
	generated$3.isUserWhitespacable = isUserWhitespacable;
	generated$3.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
	generated$3.isVariableDeclaration = isVariableDeclaration;
	generated$3.isVariableDeclarator = isVariableDeclarator;
	generated$3.isVariance = isVariance;
	generated$3.isVoidTypeAnnotation = isVoidTypeAnnotation;
	generated$3.isWhile = isWhile;
	generated$3.isWhileStatement = isWhileStatement;
	generated$3.isWithStatement = isWithStatement;
	generated$3.isYieldExpression = isYieldExpression;
	var _shallowEqual = requireShallowEqual();
	var _deprecationWarning = requireDeprecationWarning();
	function isArrayExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ArrayExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isAssignmentExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "AssignmentExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isBinaryExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "BinaryExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isInterpreterDirective(node, opts) {
	  if (!node) return false;
	  if (node.type !== "InterpreterDirective") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDirective(node, opts) {
	  if (!node) return false;
	  if (node.type !== "Directive") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDirectiveLiteral(node, opts) {
	  if (!node) return false;
	  if (node.type !== "DirectiveLiteral") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isBlockStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "BlockStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isBreakStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "BreakStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isCallExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "CallExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isCatchClause(node, opts) {
	  if (!node) return false;
	  if (node.type !== "CatchClause") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isConditionalExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ConditionalExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isContinueStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ContinueStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDebuggerStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "DebuggerStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDoWhileStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "DoWhileStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isEmptyStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "EmptyStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isExpressionStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ExpressionStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isFile(node, opts) {
	  if (!node) return false;
	  if (node.type !== "File") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isForInStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ForInStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isForStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ForStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isFunctionDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "FunctionDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isFunctionExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "FunctionExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isIdentifier(node, opts) {
	  if (!node) return false;
	  if (node.type !== "Identifier") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isIfStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "IfStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isLabeledStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "LabeledStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isStringLiteral(node, opts) {
	  if (!node) return false;
	  if (node.type !== "StringLiteral") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isNumericLiteral(node, opts) {
	  if (!node) return false;
	  if (node.type !== "NumericLiteral") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isNullLiteral(node, opts) {
	  if (!node) return false;
	  if (node.type !== "NullLiteral") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isBooleanLiteral(node, opts) {
	  if (!node) return false;
	  if (node.type !== "BooleanLiteral") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isRegExpLiteral(node, opts) {
	  if (!node) return false;
	  if (node.type !== "RegExpLiteral") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isLogicalExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "LogicalExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isMemberExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "MemberExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isNewExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "NewExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isProgram(node, opts) {
	  if (!node) return false;
	  if (node.type !== "Program") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isObjectExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ObjectExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isObjectMethod(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ObjectMethod") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isObjectProperty(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ObjectProperty") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isRestElement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "RestElement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isReturnStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ReturnStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isSequenceExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "SequenceExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isParenthesizedExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ParenthesizedExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isSwitchCase(node, opts) {
	  if (!node) return false;
	  if (node.type !== "SwitchCase") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isSwitchStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "SwitchStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isThisExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ThisExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isThrowStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ThrowStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTryStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TryStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isUnaryExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "UnaryExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isUpdateExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "UpdateExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isVariableDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "VariableDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isVariableDeclarator(node, opts) {
	  if (!node) return false;
	  if (node.type !== "VariableDeclarator") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isWhileStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "WhileStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isWithStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "WithStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isAssignmentPattern(node, opts) {
	  if (!node) return false;
	  if (node.type !== "AssignmentPattern") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isArrayPattern(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ArrayPattern") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isArrowFunctionExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ArrowFunctionExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isClassBody(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ClassBody") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isClassExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ClassExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isClassDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ClassDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isExportAllDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ExportAllDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isExportDefaultDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ExportDefaultDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isExportNamedDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ExportNamedDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isExportSpecifier(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ExportSpecifier") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isForOfStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ForOfStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isImportDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ImportDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isImportDefaultSpecifier(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ImportDefaultSpecifier") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isImportNamespaceSpecifier(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ImportNamespaceSpecifier") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isImportSpecifier(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ImportSpecifier") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isImportExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ImportExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isMetaProperty(node, opts) {
	  if (!node) return false;
	  if (node.type !== "MetaProperty") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isClassMethod(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ClassMethod") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isObjectPattern(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ObjectPattern") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isSpreadElement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "SpreadElement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isSuper(node, opts) {
	  if (!node) return false;
	  if (node.type !== "Super") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTaggedTemplateExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TaggedTemplateExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTemplateElement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TemplateElement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTemplateLiteral(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TemplateLiteral") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isYieldExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "YieldExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isAwaitExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "AwaitExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isImport(node, opts) {
	  if (!node) return false;
	  if (node.type !== "Import") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isBigIntLiteral(node, opts) {
	  if (!node) return false;
	  if (node.type !== "BigIntLiteral") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isExportNamespaceSpecifier(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ExportNamespaceSpecifier") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isOptionalMemberExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "OptionalMemberExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isOptionalCallExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "OptionalCallExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isClassProperty(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ClassProperty") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isClassAccessorProperty(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ClassAccessorProperty") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isClassPrivateProperty(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ClassPrivateProperty") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isClassPrivateMethod(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ClassPrivateMethod") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isPrivateName(node, opts) {
	  if (!node) return false;
	  if (node.type !== "PrivateName") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isStaticBlock(node, opts) {
	  if (!node) return false;
	  if (node.type !== "StaticBlock") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isAnyTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "AnyTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isArrayTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ArrayTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isBooleanTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "BooleanTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isBooleanLiteralTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "BooleanLiteralTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isNullLiteralTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "NullLiteralTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isClassImplements(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ClassImplements") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDeclareClass(node, opts) {
	  if (!node) return false;
	  if (node.type !== "DeclareClass") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDeclareFunction(node, opts) {
	  if (!node) return false;
	  if (node.type !== "DeclareFunction") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDeclareInterface(node, opts) {
	  if (!node) return false;
	  if (node.type !== "DeclareInterface") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDeclareModule(node, opts) {
	  if (!node) return false;
	  if (node.type !== "DeclareModule") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDeclareModuleExports(node, opts) {
	  if (!node) return false;
	  if (node.type !== "DeclareModuleExports") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDeclareTypeAlias(node, opts) {
	  if (!node) return false;
	  if (node.type !== "DeclareTypeAlias") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDeclareOpaqueType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "DeclareOpaqueType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDeclareVariable(node, opts) {
	  if (!node) return false;
	  if (node.type !== "DeclareVariable") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDeclareExportDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "DeclareExportDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDeclareExportAllDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "DeclareExportAllDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDeclaredPredicate(node, opts) {
	  if (!node) return false;
	  if (node.type !== "DeclaredPredicate") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isExistsTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ExistsTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isFunctionTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "FunctionTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isFunctionTypeParam(node, opts) {
	  if (!node) return false;
	  if (node.type !== "FunctionTypeParam") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isGenericTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "GenericTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isInferredPredicate(node, opts) {
	  if (!node) return false;
	  if (node.type !== "InferredPredicate") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isInterfaceExtends(node, opts) {
	  if (!node) return false;
	  if (node.type !== "InterfaceExtends") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isInterfaceDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "InterfaceDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isInterfaceTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "InterfaceTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isIntersectionTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "IntersectionTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isMixedTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "MixedTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isEmptyTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "EmptyTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isNullableTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "NullableTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isNumberLiteralTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "NumberLiteralTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isNumberTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "NumberTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isObjectTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ObjectTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isObjectTypeInternalSlot(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ObjectTypeInternalSlot") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isObjectTypeCallProperty(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ObjectTypeCallProperty") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isObjectTypeIndexer(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ObjectTypeIndexer") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isObjectTypeProperty(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ObjectTypeProperty") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isObjectTypeSpreadProperty(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ObjectTypeSpreadProperty") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isOpaqueType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "OpaqueType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isQualifiedTypeIdentifier(node, opts) {
	  if (!node) return false;
	  if (node.type !== "QualifiedTypeIdentifier") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isStringLiteralTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "StringLiteralTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isStringTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "StringTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isSymbolTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "SymbolTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isThisTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ThisTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTupleTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TupleTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTypeofTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TypeofTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTypeAlias(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TypeAlias") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTypeCastExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TypeCastExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTypeParameter(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TypeParameter") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTypeParameterDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TypeParameterDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTypeParameterInstantiation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TypeParameterInstantiation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isUnionTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "UnionTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isVariance(node, opts) {
	  if (!node) return false;
	  if (node.type !== "Variance") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isVoidTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "VoidTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isEnumDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "EnumDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isEnumBooleanBody(node, opts) {
	  if (!node) return false;
	  if (node.type !== "EnumBooleanBody") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isEnumNumberBody(node, opts) {
	  if (!node) return false;
	  if (node.type !== "EnumNumberBody") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isEnumStringBody(node, opts) {
	  if (!node) return false;
	  if (node.type !== "EnumStringBody") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isEnumSymbolBody(node, opts) {
	  if (!node) return false;
	  if (node.type !== "EnumSymbolBody") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isEnumBooleanMember(node, opts) {
	  if (!node) return false;
	  if (node.type !== "EnumBooleanMember") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isEnumNumberMember(node, opts) {
	  if (!node) return false;
	  if (node.type !== "EnumNumberMember") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isEnumStringMember(node, opts) {
	  if (!node) return false;
	  if (node.type !== "EnumStringMember") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isEnumDefaultedMember(node, opts) {
	  if (!node) return false;
	  if (node.type !== "EnumDefaultedMember") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isIndexedAccessType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "IndexedAccessType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isOptionalIndexedAccessType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "OptionalIndexedAccessType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isJSXAttribute(node, opts) {
	  if (!node) return false;
	  if (node.type !== "JSXAttribute") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isJSXClosingElement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "JSXClosingElement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isJSXElement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "JSXElement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isJSXEmptyExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "JSXEmptyExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isJSXExpressionContainer(node, opts) {
	  if (!node) return false;
	  if (node.type !== "JSXExpressionContainer") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isJSXSpreadChild(node, opts) {
	  if (!node) return false;
	  if (node.type !== "JSXSpreadChild") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isJSXIdentifier(node, opts) {
	  if (!node) return false;
	  if (node.type !== "JSXIdentifier") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isJSXMemberExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "JSXMemberExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isJSXNamespacedName(node, opts) {
	  if (!node) return false;
	  if (node.type !== "JSXNamespacedName") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isJSXOpeningElement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "JSXOpeningElement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isJSXSpreadAttribute(node, opts) {
	  if (!node) return false;
	  if (node.type !== "JSXSpreadAttribute") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isJSXText(node, opts) {
	  if (!node) return false;
	  if (node.type !== "JSXText") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isJSXFragment(node, opts) {
	  if (!node) return false;
	  if (node.type !== "JSXFragment") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isJSXOpeningFragment(node, opts) {
	  if (!node) return false;
	  if (node.type !== "JSXOpeningFragment") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isJSXClosingFragment(node, opts) {
	  if (!node) return false;
	  if (node.type !== "JSXClosingFragment") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isNoop(node, opts) {
	  if (!node) return false;
	  if (node.type !== "Noop") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isPlaceholder(node, opts) {
	  if (!node) return false;
	  if (node.type !== "Placeholder") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isV8IntrinsicIdentifier(node, opts) {
	  if (!node) return false;
	  if (node.type !== "V8IntrinsicIdentifier") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isArgumentPlaceholder(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ArgumentPlaceholder") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isBindExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "BindExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isImportAttribute(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ImportAttribute") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDecorator(node, opts) {
	  if (!node) return false;
	  if (node.type !== "Decorator") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDoExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "DoExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isExportDefaultSpecifier(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ExportDefaultSpecifier") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isRecordExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "RecordExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTupleExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TupleExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDecimalLiteral(node, opts) {
	  if (!node) return false;
	  if (node.type !== "DecimalLiteral") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isModuleExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ModuleExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTopicReference(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TopicReference") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isPipelineTopicExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "PipelineTopicExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isPipelineBareFunction(node, opts) {
	  if (!node) return false;
	  if (node.type !== "PipelineBareFunction") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isPipelinePrimaryTopicReference(node, opts) {
	  if (!node) return false;
	  if (node.type !== "PipelinePrimaryTopicReference") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSParameterProperty(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSParameterProperty") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSDeclareFunction(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSDeclareFunction") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSDeclareMethod(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSDeclareMethod") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSQualifiedName(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSQualifiedName") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSCallSignatureDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSCallSignatureDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSConstructSignatureDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSConstructSignatureDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSPropertySignature(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSPropertySignature") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSMethodSignature(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSMethodSignature") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSIndexSignature(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSIndexSignature") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSAnyKeyword(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSAnyKeyword") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSBooleanKeyword(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSBooleanKeyword") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSBigIntKeyword(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSBigIntKeyword") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSIntrinsicKeyword(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSIntrinsicKeyword") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSNeverKeyword(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSNeverKeyword") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSNullKeyword(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSNullKeyword") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSNumberKeyword(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSNumberKeyword") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSObjectKeyword(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSObjectKeyword") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSStringKeyword(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSStringKeyword") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSSymbolKeyword(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSSymbolKeyword") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSUndefinedKeyword(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSUndefinedKeyword") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSUnknownKeyword(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSUnknownKeyword") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSVoidKeyword(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSVoidKeyword") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSThisType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSThisType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSFunctionType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSFunctionType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSConstructorType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSConstructorType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSTypeReference(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSTypeReference") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSTypePredicate(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSTypePredicate") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSTypeQuery(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSTypeQuery") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSTypeLiteral(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSTypeLiteral") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSArrayType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSArrayType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSTupleType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSTupleType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSOptionalType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSOptionalType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSRestType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSRestType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSNamedTupleMember(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSNamedTupleMember") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSUnionType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSUnionType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSIntersectionType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSIntersectionType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSConditionalType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSConditionalType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSInferType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSInferType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSParenthesizedType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSParenthesizedType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSTypeOperator(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSTypeOperator") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSIndexedAccessType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSIndexedAccessType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSMappedType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSMappedType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSLiteralType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSLiteralType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSExpressionWithTypeArguments(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSExpressionWithTypeArguments") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSInterfaceDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSInterfaceDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSInterfaceBody(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSInterfaceBody") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSTypeAliasDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSTypeAliasDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSInstantiationExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSInstantiationExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSAsExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSAsExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSSatisfiesExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSSatisfiesExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSTypeAssertion(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSTypeAssertion") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSEnumDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSEnumDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSEnumMember(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSEnumMember") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSModuleDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSModuleDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSModuleBlock(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSModuleBlock") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSImportType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSImportType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSImportEqualsDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSImportEqualsDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSExternalModuleReference(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSExternalModuleReference") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSNonNullExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSNonNullExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSExportAssignment(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSExportAssignment") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSNamespaceExportDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSNamespaceExportDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSTypeParameterInstantiation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSTypeParameterInstantiation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSTypeParameterDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSTypeParameterDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSTypeParameter(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSTypeParameter") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isStandardized(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "ArrayExpression":
	    case "AssignmentExpression":
	    case "BinaryExpression":
	    case "InterpreterDirective":
	    case "Directive":
	    case "DirectiveLiteral":
	    case "BlockStatement":
	    case "BreakStatement":
	    case "CallExpression":
	    case "CatchClause":
	    case "ConditionalExpression":
	    case "ContinueStatement":
	    case "DebuggerStatement":
	    case "DoWhileStatement":
	    case "EmptyStatement":
	    case "ExpressionStatement":
	    case "File":
	    case "ForInStatement":
	    case "ForStatement":
	    case "FunctionDeclaration":
	    case "FunctionExpression":
	    case "Identifier":
	    case "IfStatement":
	    case "LabeledStatement":
	    case "StringLiteral":
	    case "NumericLiteral":
	    case "NullLiteral":
	    case "BooleanLiteral":
	    case "RegExpLiteral":
	    case "LogicalExpression":
	    case "MemberExpression":
	    case "NewExpression":
	    case "Program":
	    case "ObjectExpression":
	    case "ObjectMethod":
	    case "ObjectProperty":
	    case "RestElement":
	    case "ReturnStatement":
	    case "SequenceExpression":
	    case "ParenthesizedExpression":
	    case "SwitchCase":
	    case "SwitchStatement":
	    case "ThisExpression":
	    case "ThrowStatement":
	    case "TryStatement":
	    case "UnaryExpression":
	    case "UpdateExpression":
	    case "VariableDeclaration":
	    case "VariableDeclarator":
	    case "WhileStatement":
	    case "WithStatement":
	    case "AssignmentPattern":
	    case "ArrayPattern":
	    case "ArrowFunctionExpression":
	    case "ClassBody":
	    case "ClassExpression":
	    case "ClassDeclaration":
	    case "ExportAllDeclaration":
	    case "ExportDefaultDeclaration":
	    case "ExportNamedDeclaration":
	    case "ExportSpecifier":
	    case "ForOfStatement":
	    case "ImportDeclaration":
	    case "ImportDefaultSpecifier":
	    case "ImportNamespaceSpecifier":
	    case "ImportSpecifier":
	    case "ImportExpression":
	    case "MetaProperty":
	    case "ClassMethod":
	    case "ObjectPattern":
	    case "SpreadElement":
	    case "Super":
	    case "TaggedTemplateExpression":
	    case "TemplateElement":
	    case "TemplateLiteral":
	    case "YieldExpression":
	    case "AwaitExpression":
	    case "Import":
	    case "BigIntLiteral":
	    case "ExportNamespaceSpecifier":
	    case "OptionalMemberExpression":
	    case "OptionalCallExpression":
	    case "ClassProperty":
	    case "ClassAccessorProperty":
	    case "ClassPrivateProperty":
	    case "ClassPrivateMethod":
	    case "PrivateName":
	    case "StaticBlock":
	      break;
	    case "Placeholder":
	      switch (node.expectedNode) {
	        case "Identifier":
	        case "StringLiteral":
	        case "BlockStatement":
	        case "ClassBody":
	          break;
	        default:
	          return false;
	      }
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isExpression(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "ArrayExpression":
	    case "AssignmentExpression":
	    case "BinaryExpression":
	    case "CallExpression":
	    case "ConditionalExpression":
	    case "FunctionExpression":
	    case "Identifier":
	    case "StringLiteral":
	    case "NumericLiteral":
	    case "NullLiteral":
	    case "BooleanLiteral":
	    case "RegExpLiteral":
	    case "LogicalExpression":
	    case "MemberExpression":
	    case "NewExpression":
	    case "ObjectExpression":
	    case "SequenceExpression":
	    case "ParenthesizedExpression":
	    case "ThisExpression":
	    case "UnaryExpression":
	    case "UpdateExpression":
	    case "ArrowFunctionExpression":
	    case "ClassExpression":
	    case "ImportExpression":
	    case "MetaProperty":
	    case "Super":
	    case "TaggedTemplateExpression":
	    case "TemplateLiteral":
	    case "YieldExpression":
	    case "AwaitExpression":
	    case "Import":
	    case "BigIntLiteral":
	    case "OptionalMemberExpression":
	    case "OptionalCallExpression":
	    case "TypeCastExpression":
	    case "JSXElement":
	    case "JSXFragment":
	    case "BindExpression":
	    case "DoExpression":
	    case "RecordExpression":
	    case "TupleExpression":
	    case "DecimalLiteral":
	    case "ModuleExpression":
	    case "TopicReference":
	    case "PipelineTopicExpression":
	    case "PipelineBareFunction":
	    case "PipelinePrimaryTopicReference":
	    case "TSInstantiationExpression":
	    case "TSAsExpression":
	    case "TSSatisfiesExpression":
	    case "TSTypeAssertion":
	    case "TSNonNullExpression":
	      break;
	    case "Placeholder":
	      switch (node.expectedNode) {
	        case "Expression":
	        case "Identifier":
	        case "StringLiteral":
	          break;
	        default:
	          return false;
	      }
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isBinary(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "BinaryExpression":
	    case "LogicalExpression":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isScopable(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "BlockStatement":
	    case "CatchClause":
	    case "DoWhileStatement":
	    case "ForInStatement":
	    case "ForStatement":
	    case "FunctionDeclaration":
	    case "FunctionExpression":
	    case "Program":
	    case "ObjectMethod":
	    case "SwitchStatement":
	    case "WhileStatement":
	    case "ArrowFunctionExpression":
	    case "ClassExpression":
	    case "ClassDeclaration":
	    case "ForOfStatement":
	    case "ClassMethod":
	    case "ClassPrivateMethod":
	    case "StaticBlock":
	    case "TSModuleBlock":
	      break;
	    case "Placeholder":
	      if (node.expectedNode === "BlockStatement") break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isBlockParent(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "BlockStatement":
	    case "CatchClause":
	    case "DoWhileStatement":
	    case "ForInStatement":
	    case "ForStatement":
	    case "FunctionDeclaration":
	    case "FunctionExpression":
	    case "Program":
	    case "ObjectMethod":
	    case "SwitchStatement":
	    case "WhileStatement":
	    case "ArrowFunctionExpression":
	    case "ForOfStatement":
	    case "ClassMethod":
	    case "ClassPrivateMethod":
	    case "StaticBlock":
	    case "TSModuleBlock":
	      break;
	    case "Placeholder":
	      if (node.expectedNode === "BlockStatement") break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isBlock(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "BlockStatement":
	    case "Program":
	    case "TSModuleBlock":
	      break;
	    case "Placeholder":
	      if (node.expectedNode === "BlockStatement") break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isStatement(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "BlockStatement":
	    case "BreakStatement":
	    case "ContinueStatement":
	    case "DebuggerStatement":
	    case "DoWhileStatement":
	    case "EmptyStatement":
	    case "ExpressionStatement":
	    case "ForInStatement":
	    case "ForStatement":
	    case "FunctionDeclaration":
	    case "IfStatement":
	    case "LabeledStatement":
	    case "ReturnStatement":
	    case "SwitchStatement":
	    case "ThrowStatement":
	    case "TryStatement":
	    case "VariableDeclaration":
	    case "WhileStatement":
	    case "WithStatement":
	    case "ClassDeclaration":
	    case "ExportAllDeclaration":
	    case "ExportDefaultDeclaration":
	    case "ExportNamedDeclaration":
	    case "ForOfStatement":
	    case "ImportDeclaration":
	    case "DeclareClass":
	    case "DeclareFunction":
	    case "DeclareInterface":
	    case "DeclareModule":
	    case "DeclareModuleExports":
	    case "DeclareTypeAlias":
	    case "DeclareOpaqueType":
	    case "DeclareVariable":
	    case "DeclareExportDeclaration":
	    case "DeclareExportAllDeclaration":
	    case "InterfaceDeclaration":
	    case "OpaqueType":
	    case "TypeAlias":
	    case "EnumDeclaration":
	    case "TSDeclareFunction":
	    case "TSInterfaceDeclaration":
	    case "TSTypeAliasDeclaration":
	    case "TSEnumDeclaration":
	    case "TSModuleDeclaration":
	    case "TSImportEqualsDeclaration":
	    case "TSExportAssignment":
	    case "TSNamespaceExportDeclaration":
	      break;
	    case "Placeholder":
	      switch (node.expectedNode) {
	        case "Statement":
	        case "Declaration":
	        case "BlockStatement":
	          break;
	        default:
	          return false;
	      }
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTerminatorless(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "BreakStatement":
	    case "ContinueStatement":
	    case "ReturnStatement":
	    case "ThrowStatement":
	    case "YieldExpression":
	    case "AwaitExpression":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isCompletionStatement(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "BreakStatement":
	    case "ContinueStatement":
	    case "ReturnStatement":
	    case "ThrowStatement":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isConditional(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "ConditionalExpression":
	    case "IfStatement":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isLoop(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "DoWhileStatement":
	    case "ForInStatement":
	    case "ForStatement":
	    case "WhileStatement":
	    case "ForOfStatement":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isWhile(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "DoWhileStatement":
	    case "WhileStatement":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isExpressionWrapper(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "ExpressionStatement":
	    case "ParenthesizedExpression":
	    case "TypeCastExpression":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isFor(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "ForInStatement":
	    case "ForStatement":
	    case "ForOfStatement":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isForXStatement(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "ForInStatement":
	    case "ForOfStatement":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isFunction(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "FunctionDeclaration":
	    case "FunctionExpression":
	    case "ObjectMethod":
	    case "ArrowFunctionExpression":
	    case "ClassMethod":
	    case "ClassPrivateMethod":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isFunctionParent(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "FunctionDeclaration":
	    case "FunctionExpression":
	    case "ObjectMethod":
	    case "ArrowFunctionExpression":
	    case "ClassMethod":
	    case "ClassPrivateMethod":
	    case "StaticBlock":
	    case "TSModuleBlock":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isPureish(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "FunctionDeclaration":
	    case "FunctionExpression":
	    case "StringLiteral":
	    case "NumericLiteral":
	    case "NullLiteral":
	    case "BooleanLiteral":
	    case "RegExpLiteral":
	    case "ArrowFunctionExpression":
	    case "BigIntLiteral":
	    case "DecimalLiteral":
	      break;
	    case "Placeholder":
	      if (node.expectedNode === "StringLiteral") break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDeclaration(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "FunctionDeclaration":
	    case "VariableDeclaration":
	    case "ClassDeclaration":
	    case "ExportAllDeclaration":
	    case "ExportDefaultDeclaration":
	    case "ExportNamedDeclaration":
	    case "ImportDeclaration":
	    case "DeclareClass":
	    case "DeclareFunction":
	    case "DeclareInterface":
	    case "DeclareModule":
	    case "DeclareModuleExports":
	    case "DeclareTypeAlias":
	    case "DeclareOpaqueType":
	    case "DeclareVariable":
	    case "DeclareExportDeclaration":
	    case "DeclareExportAllDeclaration":
	    case "InterfaceDeclaration":
	    case "OpaqueType":
	    case "TypeAlias":
	    case "EnumDeclaration":
	    case "TSDeclareFunction":
	    case "TSInterfaceDeclaration":
	    case "TSTypeAliasDeclaration":
	    case "TSEnumDeclaration":
	    case "TSModuleDeclaration":
	      break;
	    case "Placeholder":
	      if (node.expectedNode === "Declaration") break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isPatternLike(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "Identifier":
	    case "RestElement":
	    case "AssignmentPattern":
	    case "ArrayPattern":
	    case "ObjectPattern":
	    case "TSAsExpression":
	    case "TSSatisfiesExpression":
	    case "TSTypeAssertion":
	    case "TSNonNullExpression":
	      break;
	    case "Placeholder":
	      switch (node.expectedNode) {
	        case "Pattern":
	        case "Identifier":
	          break;
	        default:
	          return false;
	      }
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isLVal(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "Identifier":
	    case "MemberExpression":
	    case "RestElement":
	    case "AssignmentPattern":
	    case "ArrayPattern":
	    case "ObjectPattern":
	    case "TSParameterProperty":
	    case "TSAsExpression":
	    case "TSSatisfiesExpression":
	    case "TSTypeAssertion":
	    case "TSNonNullExpression":
	      break;
	    case "Placeholder":
	      switch (node.expectedNode) {
	        case "Pattern":
	        case "Identifier":
	          break;
	        default:
	          return false;
	      }
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSEntityName(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "Identifier":
	    case "TSQualifiedName":
	      break;
	    case "Placeholder":
	      if (node.expectedNode === "Identifier") break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isLiteral(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "StringLiteral":
	    case "NumericLiteral":
	    case "NullLiteral":
	    case "BooleanLiteral":
	    case "RegExpLiteral":
	    case "TemplateLiteral":
	    case "BigIntLiteral":
	    case "DecimalLiteral":
	      break;
	    case "Placeholder":
	      if (node.expectedNode === "StringLiteral") break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isImmutable(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "StringLiteral":
	    case "NumericLiteral":
	    case "NullLiteral":
	    case "BooleanLiteral":
	    case "BigIntLiteral":
	    case "JSXAttribute":
	    case "JSXClosingElement":
	    case "JSXElement":
	    case "JSXExpressionContainer":
	    case "JSXSpreadChild":
	    case "JSXOpeningElement":
	    case "JSXText":
	    case "JSXFragment":
	    case "JSXOpeningFragment":
	    case "JSXClosingFragment":
	    case "DecimalLiteral":
	      break;
	    case "Placeholder":
	      if (node.expectedNode === "StringLiteral") break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isUserWhitespacable(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "ObjectMethod":
	    case "ObjectProperty":
	    case "ObjectTypeInternalSlot":
	    case "ObjectTypeCallProperty":
	    case "ObjectTypeIndexer":
	    case "ObjectTypeProperty":
	    case "ObjectTypeSpreadProperty":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isMethod(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "ObjectMethod":
	    case "ClassMethod":
	    case "ClassPrivateMethod":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isObjectMember(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "ObjectMethod":
	    case "ObjectProperty":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isProperty(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "ObjectProperty":
	    case "ClassProperty":
	    case "ClassAccessorProperty":
	    case "ClassPrivateProperty":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isUnaryLike(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "UnaryExpression":
	    case "SpreadElement":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isPattern(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "AssignmentPattern":
	    case "ArrayPattern":
	    case "ObjectPattern":
	      break;
	    case "Placeholder":
	      if (node.expectedNode === "Pattern") break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isClass(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "ClassExpression":
	    case "ClassDeclaration":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isImportOrExportDeclaration(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "ExportAllDeclaration":
	    case "ExportDefaultDeclaration":
	    case "ExportNamedDeclaration":
	    case "ImportDeclaration":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isExportDeclaration(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "ExportAllDeclaration":
	    case "ExportDefaultDeclaration":
	    case "ExportNamedDeclaration":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isModuleSpecifier(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "ExportSpecifier":
	    case "ImportDefaultSpecifier":
	    case "ImportNamespaceSpecifier":
	    case "ImportSpecifier":
	    case "ExportNamespaceSpecifier":
	    case "ExportDefaultSpecifier":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isAccessor(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "ClassAccessorProperty":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isPrivate(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "ClassPrivateProperty":
	    case "ClassPrivateMethod":
	    case "PrivateName":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isFlow(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "AnyTypeAnnotation":
	    case "ArrayTypeAnnotation":
	    case "BooleanTypeAnnotation":
	    case "BooleanLiteralTypeAnnotation":
	    case "NullLiteralTypeAnnotation":
	    case "ClassImplements":
	    case "DeclareClass":
	    case "DeclareFunction":
	    case "DeclareInterface":
	    case "DeclareModule":
	    case "DeclareModuleExports":
	    case "DeclareTypeAlias":
	    case "DeclareOpaqueType":
	    case "DeclareVariable":
	    case "DeclareExportDeclaration":
	    case "DeclareExportAllDeclaration":
	    case "DeclaredPredicate":
	    case "ExistsTypeAnnotation":
	    case "FunctionTypeAnnotation":
	    case "FunctionTypeParam":
	    case "GenericTypeAnnotation":
	    case "InferredPredicate":
	    case "InterfaceExtends":
	    case "InterfaceDeclaration":
	    case "InterfaceTypeAnnotation":
	    case "IntersectionTypeAnnotation":
	    case "MixedTypeAnnotation":
	    case "EmptyTypeAnnotation":
	    case "NullableTypeAnnotation":
	    case "NumberLiteralTypeAnnotation":
	    case "NumberTypeAnnotation":
	    case "ObjectTypeAnnotation":
	    case "ObjectTypeInternalSlot":
	    case "ObjectTypeCallProperty":
	    case "ObjectTypeIndexer":
	    case "ObjectTypeProperty":
	    case "ObjectTypeSpreadProperty":
	    case "OpaqueType":
	    case "QualifiedTypeIdentifier":
	    case "StringLiteralTypeAnnotation":
	    case "StringTypeAnnotation":
	    case "SymbolTypeAnnotation":
	    case "ThisTypeAnnotation":
	    case "TupleTypeAnnotation":
	    case "TypeofTypeAnnotation":
	    case "TypeAlias":
	    case "TypeAnnotation":
	    case "TypeCastExpression":
	    case "TypeParameter":
	    case "TypeParameterDeclaration":
	    case "TypeParameterInstantiation":
	    case "UnionTypeAnnotation":
	    case "Variance":
	    case "VoidTypeAnnotation":
	    case "EnumDeclaration":
	    case "EnumBooleanBody":
	    case "EnumNumberBody":
	    case "EnumStringBody":
	    case "EnumSymbolBody":
	    case "EnumBooleanMember":
	    case "EnumNumberMember":
	    case "EnumStringMember":
	    case "EnumDefaultedMember":
	    case "IndexedAccessType":
	    case "OptionalIndexedAccessType":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isFlowType(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "AnyTypeAnnotation":
	    case "ArrayTypeAnnotation":
	    case "BooleanTypeAnnotation":
	    case "BooleanLiteralTypeAnnotation":
	    case "NullLiteralTypeAnnotation":
	    case "ExistsTypeAnnotation":
	    case "FunctionTypeAnnotation":
	    case "GenericTypeAnnotation":
	    case "InterfaceTypeAnnotation":
	    case "IntersectionTypeAnnotation":
	    case "MixedTypeAnnotation":
	    case "EmptyTypeAnnotation":
	    case "NullableTypeAnnotation":
	    case "NumberLiteralTypeAnnotation":
	    case "NumberTypeAnnotation":
	    case "ObjectTypeAnnotation":
	    case "StringLiteralTypeAnnotation":
	    case "StringTypeAnnotation":
	    case "SymbolTypeAnnotation":
	    case "ThisTypeAnnotation":
	    case "TupleTypeAnnotation":
	    case "TypeofTypeAnnotation":
	    case "UnionTypeAnnotation":
	    case "VoidTypeAnnotation":
	    case "IndexedAccessType":
	    case "OptionalIndexedAccessType":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isFlowBaseAnnotation(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "AnyTypeAnnotation":
	    case "BooleanTypeAnnotation":
	    case "NullLiteralTypeAnnotation":
	    case "MixedTypeAnnotation":
	    case "EmptyTypeAnnotation":
	    case "NumberTypeAnnotation":
	    case "StringTypeAnnotation":
	    case "SymbolTypeAnnotation":
	    case "ThisTypeAnnotation":
	    case "VoidTypeAnnotation":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isFlowDeclaration(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "DeclareClass":
	    case "DeclareFunction":
	    case "DeclareInterface":
	    case "DeclareModule":
	    case "DeclareModuleExports":
	    case "DeclareTypeAlias":
	    case "DeclareOpaqueType":
	    case "DeclareVariable":
	    case "DeclareExportDeclaration":
	    case "DeclareExportAllDeclaration":
	    case "InterfaceDeclaration":
	    case "OpaqueType":
	    case "TypeAlias":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isFlowPredicate(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "DeclaredPredicate":
	    case "InferredPredicate":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isEnumBody(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "EnumBooleanBody":
	    case "EnumNumberBody":
	    case "EnumStringBody":
	    case "EnumSymbolBody":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isEnumMember(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "EnumBooleanMember":
	    case "EnumNumberMember":
	    case "EnumStringMember":
	    case "EnumDefaultedMember":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isJSX(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "JSXAttribute":
	    case "JSXClosingElement":
	    case "JSXElement":
	    case "JSXEmptyExpression":
	    case "JSXExpressionContainer":
	    case "JSXSpreadChild":
	    case "JSXIdentifier":
	    case "JSXMemberExpression":
	    case "JSXNamespacedName":
	    case "JSXOpeningElement":
	    case "JSXSpreadAttribute":
	    case "JSXText":
	    case "JSXFragment":
	    case "JSXOpeningFragment":
	    case "JSXClosingFragment":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isMiscellaneous(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "Noop":
	    case "Placeholder":
	    case "V8IntrinsicIdentifier":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTypeScript(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "TSParameterProperty":
	    case "TSDeclareFunction":
	    case "TSDeclareMethod":
	    case "TSQualifiedName":
	    case "TSCallSignatureDeclaration":
	    case "TSConstructSignatureDeclaration":
	    case "TSPropertySignature":
	    case "TSMethodSignature":
	    case "TSIndexSignature":
	    case "TSAnyKeyword":
	    case "TSBooleanKeyword":
	    case "TSBigIntKeyword":
	    case "TSIntrinsicKeyword":
	    case "TSNeverKeyword":
	    case "TSNullKeyword":
	    case "TSNumberKeyword":
	    case "TSObjectKeyword":
	    case "TSStringKeyword":
	    case "TSSymbolKeyword":
	    case "TSUndefinedKeyword":
	    case "TSUnknownKeyword":
	    case "TSVoidKeyword":
	    case "TSThisType":
	    case "TSFunctionType":
	    case "TSConstructorType":
	    case "TSTypeReference":
	    case "TSTypePredicate":
	    case "TSTypeQuery":
	    case "TSTypeLiteral":
	    case "TSArrayType":
	    case "TSTupleType":
	    case "TSOptionalType":
	    case "TSRestType":
	    case "TSNamedTupleMember":
	    case "TSUnionType":
	    case "TSIntersectionType":
	    case "TSConditionalType":
	    case "TSInferType":
	    case "TSParenthesizedType":
	    case "TSTypeOperator":
	    case "TSIndexedAccessType":
	    case "TSMappedType":
	    case "TSLiteralType":
	    case "TSExpressionWithTypeArguments":
	    case "TSInterfaceDeclaration":
	    case "TSInterfaceBody":
	    case "TSTypeAliasDeclaration":
	    case "TSInstantiationExpression":
	    case "TSAsExpression":
	    case "TSSatisfiesExpression":
	    case "TSTypeAssertion":
	    case "TSEnumDeclaration":
	    case "TSEnumMember":
	    case "TSModuleDeclaration":
	    case "TSModuleBlock":
	    case "TSImportType":
	    case "TSImportEqualsDeclaration":
	    case "TSExternalModuleReference":
	    case "TSNonNullExpression":
	    case "TSExportAssignment":
	    case "TSNamespaceExportDeclaration":
	    case "TSTypeAnnotation":
	    case "TSTypeParameterInstantiation":
	    case "TSTypeParameterDeclaration":
	    case "TSTypeParameter":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSTypeElement(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "TSCallSignatureDeclaration":
	    case "TSConstructSignatureDeclaration":
	    case "TSPropertySignature":
	    case "TSMethodSignature":
	    case "TSIndexSignature":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSType(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "TSAnyKeyword":
	    case "TSBooleanKeyword":
	    case "TSBigIntKeyword":
	    case "TSIntrinsicKeyword":
	    case "TSNeverKeyword":
	    case "TSNullKeyword":
	    case "TSNumberKeyword":
	    case "TSObjectKeyword":
	    case "TSStringKeyword":
	    case "TSSymbolKeyword":
	    case "TSUndefinedKeyword":
	    case "TSUnknownKeyword":
	    case "TSVoidKeyword":
	    case "TSThisType":
	    case "TSFunctionType":
	    case "TSConstructorType":
	    case "TSTypeReference":
	    case "TSTypePredicate":
	    case "TSTypeQuery":
	    case "TSTypeLiteral":
	    case "TSArrayType":
	    case "TSTupleType":
	    case "TSOptionalType":
	    case "TSRestType":
	    case "TSUnionType":
	    case "TSIntersectionType":
	    case "TSConditionalType":
	    case "TSInferType":
	    case "TSParenthesizedType":
	    case "TSTypeOperator":
	    case "TSIndexedAccessType":
	    case "TSMappedType":
	    case "TSLiteralType":
	    case "TSExpressionWithTypeArguments":
	    case "TSImportType":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSBaseType(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "TSAnyKeyword":
	    case "TSBooleanKeyword":
	    case "TSBigIntKeyword":
	    case "TSIntrinsicKeyword":
	    case "TSNeverKeyword":
	    case "TSNullKeyword":
	    case "TSNumberKeyword":
	    case "TSObjectKeyword":
	    case "TSStringKeyword":
	    case "TSSymbolKeyword":
	    case "TSUndefinedKeyword":
	    case "TSUnknownKeyword":
	    case "TSVoidKeyword":
	    case "TSThisType":
	    case "TSLiteralType":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isNumberLiteral(node, opts) {
	  (0, _deprecationWarning.default)("isNumberLiteral", "isNumericLiteral");
	  if (!node) return false;
	  if (node.type !== "NumberLiteral") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isRegexLiteral(node, opts) {
	  (0, _deprecationWarning.default)("isRegexLiteral", "isRegExpLiteral");
	  if (!node) return false;
	  if (node.type !== "RegexLiteral") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isRestProperty(node, opts) {
	  (0, _deprecationWarning.default)("isRestProperty", "isRestElement");
	  if (!node) return false;
	  if (node.type !== "RestProperty") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isSpreadProperty(node, opts) {
	  (0, _deprecationWarning.default)("isSpreadProperty", "isSpreadElement");
	  if (!node) return false;
	  if (node.type !== "SpreadProperty") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isModuleDeclaration(node, opts) {
	  (0, _deprecationWarning.default)("isModuleDeclaration", "isImportOrExportDeclaration");
	  return isImportOrExportDeclaration(node, opts);
	}

	
	return generated$3;
}

var hasRequiredMatchesPattern;

function requireMatchesPattern () {
	if (hasRequiredMatchesPattern) return matchesPattern;
	hasRequiredMatchesPattern = 1;

	Object.defineProperty(matchesPattern, "__esModule", {
	  value: true
	});
	matchesPattern.default = matchesPattern$1;
	var _index = requireGenerated$3();
	function matchesPattern$1(member, match, allowPartial) {
	  if (!(0, _index.isMemberExpression)(member)) return false;
	  const parts = Array.isArray(match) ? match : match.split(".");
	  const nodes = [];
	  let node;
	  for (node = member; (0, _index.isMemberExpression)(node); node = node.object) {
	    nodes.push(node.property);
	  }
	  nodes.push(node);
	  if (nodes.length < parts.length) return false;
	  if (!allowPartial && nodes.length > parts.length) return false;
	  for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
	    const node = nodes[j];
	    let value;
	    if ((0, _index.isIdentifier)(node)) {
	      value = node.name;
	    } else if ((0, _index.isStringLiteral)(node)) {
	      value = node.value;
	    } else if ((0, _index.isThisExpression)(node)) {
	      value = "this";
	    } else {
	      return false;
	    }
	    if (parts[i] !== value) return false;
	  }
	  return true;
	}

	
	return matchesPattern;
}

var hasRequiredBuildMatchMemberExpression;

function requireBuildMatchMemberExpression () {
	if (hasRequiredBuildMatchMemberExpression) return buildMatchMemberExpression;
	hasRequiredBuildMatchMemberExpression = 1;

	Object.defineProperty(buildMatchMemberExpression, "__esModule", {
	  value: true
	});
	buildMatchMemberExpression.default = buildMatchMemberExpression$1;
	var _matchesPattern = requireMatchesPattern();
	function buildMatchMemberExpression$1(match, allowPartial) {
	  const parts = match.split(".");
	  return member => (0, _matchesPattern.default)(member, parts, allowPartial);
	}

	
	return buildMatchMemberExpression;
}

var hasRequiredIsReactComponent;

function requireIsReactComponent () {
	if (hasRequiredIsReactComponent) return isReactComponent;
	hasRequiredIsReactComponent = 1;

	Object.defineProperty(isReactComponent, "__esModule", {
	  value: true
	});
	isReactComponent.default = void 0;
	var _buildMatchMemberExpression = requireBuildMatchMemberExpression();
	const isReactComponent$1 = (0, _buildMatchMemberExpression.default)("React.Component");
	isReactComponent.default = isReactComponent$1;

	
	return isReactComponent;
}

var isCompatTag = {};

var hasRequiredIsCompatTag;

function requireIsCompatTag () {
	if (hasRequiredIsCompatTag) return isCompatTag;
	hasRequiredIsCompatTag = 1;

	Object.defineProperty(isCompatTag, "__esModule", {
	  value: true
	});
	isCompatTag.default = isCompatTag$1;
	function isCompatTag$1(tagName) {
	  return !!tagName && /^[a-z]/.test(tagName);
	}

	
	return isCompatTag;
}

var buildChildren = {};

var cleanJSXElementLiteralChild = {};

var generated$2 = {};

var validate$1 = {};

var definitions = {};

var core = {};

var is = {};

var isType = {};

var hasRequiredIsType;

function requireIsType () {
	if (hasRequiredIsType) return isType;
	hasRequiredIsType = 1;

	Object.defineProperty(isType, "__esModule", {
	  value: true
	});
	isType.default = isType$1;
	var _index = requireDefinitions();
	function isType$1(nodeType, targetType) {
	  if (nodeType === targetType) return true;
	  if (nodeType == null) return false;
	  if (_index.ALIAS_KEYS[targetType]) return false;
	  const aliases = _index.FLIPPED_ALIAS_KEYS[targetType];
	  if (aliases) {
	    if (aliases[0] === nodeType) return true;
	    for (const alias of aliases) {
	      if (nodeType === alias) return true;
	    }
	  }
	  return false;
	}

	
	return isType;
}

var isPlaceholderType = {};

var hasRequiredIsPlaceholderType;

function requireIsPlaceholderType () {
	if (hasRequiredIsPlaceholderType) return isPlaceholderType;
	hasRequiredIsPlaceholderType = 1;

	Object.defineProperty(isPlaceholderType, "__esModule", {
	  value: true
	});
	isPlaceholderType.default = isPlaceholderType$1;
	var _index = requireDefinitions();
	function isPlaceholderType$1(placeholderType, targetType) {
	  if (placeholderType === targetType) return true;
	  const aliases = _index.PLACEHOLDERS_ALIAS[placeholderType];
	  if (aliases) {
	    for (const alias of aliases) {
	      if (targetType === alias) return true;
	    }
	  }
	  return false;
	}

	
	return isPlaceholderType;
}

var hasRequiredIs;

function requireIs () {
	if (hasRequiredIs) return is;
	hasRequiredIs = 1;

	Object.defineProperty(is, "__esModule", {
	  value: true
	});
	is.default = is$1;
	var _shallowEqual = requireShallowEqual();
	var _isType = requireIsType();
	var _isPlaceholderType = requireIsPlaceholderType();
	var _index = requireDefinitions();
	function is$1(type, node, opts) {
	  if (!node) return false;
	  const matches = (0, _isType.default)(node.type, type);
	  if (!matches) {
	    if (!opts && node.type === "Placeholder" && type in _index.FLIPPED_ALIAS_KEYS) {
	      return (0, _isPlaceholderType.default)(node.expectedNode, type);
	    }
	    return false;
	  }
	  if (opts === undefined) {
	    return true;
	  } else {
	    return (0, _shallowEqual.default)(node, opts);
	  }
	}

	
	return is;
}

var isValidIdentifier = {};

var lib$2 = {};

var identifier = {};

var hasRequiredIdentifier;

function requireIdentifier () {
	if (hasRequiredIdentifier) return identifier;
	hasRequiredIdentifier = 1;

	Object.defineProperty(identifier, "__esModule", {
	  value: true
	});
	identifier.isIdentifierChar = isIdentifierChar;
	identifier.isIdentifierName = isIdentifierName;
	identifier.isIdentifierStart = isIdentifierStart;
	let nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c8a\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7cd\ua7d0\ua7d1\ua7d3\ua7d5-\ua7dc\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
	let nonASCIIidentifierChars = "\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0897-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0cf3\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0e